var documenterSearchIndex = {"docs":
[{"location":"simulations_delays/#Simulating-delayed-time-series","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"Let's simulate two time series with a delay\n\nusing Tonari\nusing Random\nusing Plots\nusing StatsBase\nrng = MersenneTwister(42)\n\nLet's define the individual power spectral densities and the phase delay. We will use two bending power laws and a constant time delay.\n\np1 = SingleBendingPowerLaw(1.0, 0.63, 10e-2, 3.22)\np2 = SingleBendingPowerLaw(1.0, 0.78, 13e-2, 3.81)\nÎ”Ï• = ConstantTimeLag(12.35)\n\nThe cross-spectral density is defined by the two power spectral densities and the phase delay.\n\ncs = CrossSpectralDensity(p1, p2, Î”Ï•)\n\nWe can now simulate the time series using the Simulation type.\n\nT, Î”t = 504.2, 0.133\nsimu = Simulation(cs, T, Î”t)\n\nand sample 50 time series.\n\nt, y, yerr = sample(rng,simu,50,error_size=0.15)\n\nscatter(t,y[1][:,1],yerr=yerr[1][:,1],label=\"1\", framestyle=:box)\nscatter!(t,y[2][:,1],yerr=yerr[2][:,1],label=\"2\", framestyle=:box, xlabel=\"Time (days)\", ylabel=\"Value\")\n\nThe cross periodogram can be computed using the cross_periodogram function. Î³Â² is the coherence, Î”Ï† the phase difference and Î”Ï„ the time delay.\n\nf, Î³Â², Î³Â²_corrected, Î”Ï†, Î³Â²_err, Î³Â²_corrected_err, Î”Ï†_err, Î”Ï„, Î”Ï„_err, PÌ„â‚, PÌ„â‚‚, Nâ‚, Nâ‚‚, n = cross_periodogram(t, y[1], y[2], yerr[1],yerr[2])\n\nThe individual periodograms can be plotted:\n\nplot(f,PÌ„â‚,label=\"Pâ‚\")\nplot!(f,PÌ„â‚‚,xscale=:log10,yscale=:log10,label=\"Pâ‚‚\",xlabel=\"Frequency (d^-1)\",ylabel=\"Power\")\nhline!([Nâ‚,Nâ‚‚],linestyle=:dash,label=\"noise level\", framestyle=:box)\n\nThe coherence and the phase difference can be plotted as a function of the frequency:\n\nl = @layout [a; b]\np1 = scatter(f, Î³Â²_corrected, yerr=Î³Â²_corrected_err, label=\"Î³Â² corrected\",marker=:square,ms=4,xscale=:log10,size=(800,400))\np1 = scatter!(f, Î³Â², yerr=Î³Â²_err, label=\"Î³Â²\", xscale=:log10,ylims=(0,1.1),ms=4,ylabel=\"Coherence\",link=:x, framestyle=:box)\np2 = scatter(f, Î”Ï„, yerr=Î”Ï„_err, xscale=:log10, ylabel=\"Time delay (d)\",xlabel=\"Frequency (d^-1)\",link=:x, framestyle=:box,label=nothing)\np2 = hline!([Î”Ï•.Î”Ï„ ],color=:black,label=\"True delay\")\nplot(p1, p2, layout=l,size=(800,600))","category":"section"},{"location":"simulations_delays/#With-a-constant-phaselag","page":"Simulating delayed time series","title":"With a constant phaselag","text":"p1 = SingleBendingPowerLaw(1.0, 0.63, 10e-2, 3.22)\np2 = SingleBendingPowerLaw(1.0, 0.78, 13e-2, 3.81)\nÎ”Ï• = ConstantPhaseLag(56.2,5*1/T)\n\ncs = CrossSpectralDensity(p1, p2, Î”Ï•)\n\nT, Î”t = 504.2, 0.133\nsimu = Simulation(cs, T, Î”t)\n\nt, y, yerr = sample(rng,simu,50,error_size=0.15)\n\nscatter(t,y[1][:,1],yerr=yerr[1][:,1],label=\"1\", framestyle=:box)\nscatter!(t,y[2][:,1],yerr=yerr[2][:,1],label=\"2\", framestyle=:box, xlabel=\"Time (days)\", ylabel=\"Value\")\n\nf, Î³Â², Î³Â²_corrected, Î”Ï†, Î³Â²_err, Î³Â²_corrected_err, Î”Ï†_err, Î”Ï„, Î”Ï„_err, PÌ„â‚, PÌ„â‚‚, Nâ‚, Nâ‚‚, n = cross_periodogram(t, y[1], y[2], yerr[1],yerr[2])\n\nplot(f,PÌ„â‚,label=\"Pâ‚\")\nplot!(f,PÌ„â‚‚,xscale=:log10,yscale=:log10,label=\"Pâ‚‚\",xlabel=\"Frequency (d^-1)\",ylabel=\"Power\")\nhline!([Nâ‚,Nâ‚‚],linestyle=:dash,label=\"noise level\", framestyle=:box)\n\nl = @layout [a; b ; c]\np1 = scatter(f, Î³Â²_corrected, yerr=Î³Â²_corrected_err, label=\"Î³Â² corrected\",marker=:square,ms=4,xscale=:log10,size=(800,400))\np1 = scatter!(f, Î³Â², yerr=Î³Â²_err, label=\"Î³Â²\", xscale=:log10,ylims=(0,1.1),ms=4,ylabel=\"Coherence\",link=:x, framestyle=:box)\n\np2 = scatter(f, Î”Ï†, yerr=Î”Ï†_err, xscale=:log10, ylabel=\"Time delay (d)\",xlabel=\"Frequency (d^-1)\",link=:x, framestyle=:box,label=nothing)\np2 = plot!(f,Î”Ï•(f) .* 2 .*pi .* f )\nprintln(Î”Ï•(f[1]) .* 2 .*pi .* f[1] )\n\np3 = scatter(f, Î”Ï„, yerr=Î”Ï„_err, xscale=:log10, ylabel=\"Time delay (d)\",xlabel=\"Frequency (d^-1)\",link=:x, framestyle=:box,label=nothing)\np3 = plot!(f,-Î”Ï•(f) )\n\nplot(p1, p2,p3, layout=l,size=(800,900))","category":"section"},{"location":"references/#References","page":"References","title":"References","text":"Edelson,Â R.; Gelbord,Â J.; Cackett,Â E.; Connolly,Â S.; Done,Â C.; Fausnaugh,Â M.; Gardner,Â E.; Gehrels,Â N.; Goad,Â M.; Horne,Â K.; McHardy,Â I.; Peterson,Â B.; Vaughan,Â S.; Vestergaard,Â M.; Breeveld,Â A.; Barth,Â A.; Bentz,Â M.; Bottorff,Â M.; Brandt,Â W.; Crawford,Â S.; Dalla BontÃ ,Â E.; Emmanoulopoulos,Â D.; Evans,Â P.; Figuera Jaimes,Â R.; Filippenko,Â A.; Ferland,Â G.; Grupe,Â D.; Joner,Â M.; Kennea,Â J.; Korista,Â K.; Krimm,Â H.; Kriss,Â G.; Leonard,Â D.; Mathur,Â S.; Netzer,Â H.; Nousek,Â J.; Page,Â K.; Romero-Colmenero,Â E.; Siegel,Â M.; Starkey,Â D.; Treu,Â T.; Vogler,Â H.; Winkler,Â H. and Zheng,Â W. (2017). Swift Monitoring of NGC 4151: Evidence for a Second X-Ray/UV Reprocessing, apj 840, 41, arXiv:1703.06901 [astro-ph.HE].\n\n\n\nEdelson,Â R. and Krolik,Â J. (1988). The Discrete Correlation Function: A New Method for Analyzing Unevenly Sampled Variability Data, apj 333, 646.\n\n\n\nGaskell,Â C. and Sparke,Â L. (1986). Line Variations in Quasars and Seyfert Galaxies, apj 305, 175.\n\n\n\nPeterson,Â B.Â M.; Wanders,Â I.; Horne,Â K.; Collier,Â S.; Alexander,Â T.; Kaspi,Â S. and Maoz,Â D. (1998). On Uncertainties in Cross-Correlation Lags and the Reality of Wavelength-dependent Continuum Lags in Active Galactic Nuclei, pasp 110, 660â€“670, arXiv:astro-ph/9802103 [astro-ph].\n\n\n\nTimmer,Â J. and KÃ¶nig,Â M. (1995). On generating power law noise. aap 300, 707.\n\n\n\nVaughan,Â B.Â A. and Nowak,Â M.Â A. (1997). X-Ray Variability Coherence: How to Compute It, What It Means, and How It Constrains Models of GX 339-4 and Cygnus X-1, apjl 474, L43-L46, arXiv:astro-ph/9610257 [astro-ph].\n\n\n\nVaughan,Â S.; Edelson,Â R.; Warwick,Â R. and Uttley,Â P. (2003). On characterizing the variability properties of X-ray light curves from active galaxies, mnras 345, 1271â€“1284, arXiv:astro-ph/0307420 [astro-ph].\n\n\n\n","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Time-series","page":"API Reference","title":"Time series","text":"","category":"section"},{"location":"api/#Models","page":"API Reference","title":"Models","text":"","category":"section"},{"location":"api/#Power-spectral-densities","page":"API Reference","title":"Power spectral densities","text":"","category":"section"},{"location":"api/#Simulations","page":"API Reference","title":"Simulations","text":"","category":"section"},{"location":"api/#Periodogram","page":"API Reference","title":"Periodogram","text":"","category":"section"},{"location":"api/#Correlations","page":"API Reference","title":"Correlations","text":"","category":"section"},{"location":"api/#Tonari.IrregularTimeStamps","page":"API Reference","title":"Tonari.IrregularTimeStamps","text":"IrregularTimeStamps\n\nA structure to store the time stamps of a time series. It contains the time stamps, the time step, the duration of the time series and a boolean to indicate if the time stamps are irregular. If the time stamps are irregular, the time step is the minimum time step between two time stamps.\n\nFields\n\ntime::AbstractVector{T}: the time stamps\nunit::Unitful.Unit: the unit of the time stamps (e.g. seconds, days, etc)\ntimezero::Td: the time of the first time stamp\nÎ”t::T: the time step\nduration::T: the duration of the time series\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.RegularTimeStamps","page":"API Reference","title":"Tonari.RegularTimeStamps","text":"RegularTimeStamps\n\nA structure to store the time stamps of a time series. It contains the time stamps, the time step, the duration of the time series and a boolean to indicate if the time stamps are irregular. If the time stamps are irregular, the time step is the minimum time step between two time stamps.\n\nFields\n\nÎ”t::T: the time step\nduration::T: the duration of the time series\nunit::Unitful.Unit: the unit of the time stamps (e.g. seconds, days, etc)\ntimezero::Td: the time of the first time stamp\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.TimeSeries","page":"API Reference","title":"Tonari.TimeSeries","text":"TimeSeries\n\nA structure to store a time series. It contains the time stamps, the data, and a dictionary to store metadata.\n\nFields\n\ntime::TimeStamps{Tt,Tz}: the time stamps\ndata::TimeSeriesData{Td, N}: the data\nmetadata::Dict{Symbol, Any}: a dictionary to store metadata\n\nEntries in metadata\n\n:name: a string to store the name of the time series\n:description: a string to store a description of the time series\n:unit: a string to store the unit(s) of the data\n:unit_time: unit of the time stamps (default: seconds)\n:timezero: a string to store the time of the first time stamp\n:fake: a boolean to indicate if the time series is fake\n:instrument: a string to store the instrument used to measure the time series\n:irregular: a boolean to indicate if the time series has irregular time stamps\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.TimeSeries-Union{Tuple{Td}, Tuple{T}, Tuple{AbstractVector{T}, Union{AbstractMatrix{Td}, Vector{Td}}}, Tuple{AbstractVector{T}, Union{AbstractMatrix{Td}, Vector{Td}}, Dict{Symbol, Any}}} where {T, Td}","page":"API Reference","title":"Tonari.TimeSeries","text":"TimeSeries(time::AbstractVector{T}, data::AbstractVector{Td}, metadata::Dict{Symbol,Any} = Dict{Symbol,Any}(), atol::T=0) where {T, Td}\n\nA constructor for the TimeSeries structure.\n\nThis function lets you create a TimeSeries structure using the times, data, and optional metadata.\n\nArguments\n\ntime::AbstractVector{T}: the time stamps of the time series (length N)\ndata::AbstractVector{Td}: the data array (N x M) where N is the number of time stamps and M is the number of columns, M can be 1 for a single column, then data is a vector\nmetadata::Dict{Symbol,Any}: a dictionary to store metadata\natol::T=0: the absolute tolerance for the time stamps to check if they are regular\n\nMetadata (optional but highly recommended)\n\n:irregular::Bool : a boolean to indicate if the time stamps are irregular\n:unit_time: the unit of the time stamps (default: seconds) using Unitful\n:timezero: the time of the first time stamp (default: time[1])\n:columns: the names of the columns (length M, default: y1, y2, ...), if M = 1, then the column is a Symbol\n:unit: the units of the columns (using Unitful) (length M, default: dimensionless), if M = 1, then the unit is a Symbol, but if all columns have the same unit, then the unit is a single unit\n:name: the name of the time series (optional)\n:description: a description of the time series (optional)\n:fake: a boolean to indicate if the time series is fake (optional)\n:instrument: the instrument used to measure the time series (optional)\n\nReturns\n\nTimeSeries: a TimeSeries structure with the time stamps, data, and metadata\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.TimeSeriesData","page":"API Reference","title":"Tonari.TimeSeriesData","text":"TimeSeriesData\n\nA type for the data in the time series.\n\nFields\n\nUnion{Vector{Symbol},Symbol}: the names of the columns, e.g. flux, error. Can be a vector of symbols or a single symbol if there is only one column.\ndata::Union{AbstractArray{T,2},Vector{T}}: the data array. Can be a matrix of data or a vector if there is only one column.\nunits::Union{Vector{Tu},Tu}: the units of the data. Can be a vector of units or a single unit if there is only one column or the same unit is used for all columns.\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.fill_gaps","page":"API Reference","title":"Tonari.fill_gaps","text":"fill_gaps(rng::AbstractRNG, t::Vector{Float64}, x::Vector{Float64}, Ïƒâ‚“ = nothing; randomise_values::Bool = true, poisson::Bool = true)\n\nFill gaps in a time series data with linear interpolation. If randomise_values = true, the interpolated values are drawn from a normal distribution with the mean and standard deviation of the data. If poisson = true, the interpolated values are drawn from a Poisson distribution with the mean of the data.\n\nArguments\n\nrng::AbstractRNG: random number generator\nt::Vector{Float64}: time array\nx::Vector{Float64}: data array\nÏƒâ‚“::Vector{Float64}: standard deviation of the data array (optional)\nrandomise_values::Bool: whether to randomise the interpolated values (default: true)\npoisson::Bool: whether to use a Poisson distribution for the interpolated values, this assumes that the data is in counts/dt units (default: true)\nÎ”t::Float64: the time step of the time series (optional)\n\nReturns\n\nt_filled::Vector{Float64}: the time array with the gaps filled\nx_filled::Vector{Float64}: the data array with the gaps filled\nÏƒ_filled::Vector{Float64}: the standard deviation of the data array with the gaps filled (optional)\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.time_series_sanity_checks-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, Any}} where T","page":"API Reference","title":"Tonari.time_series_sanity_checks","text":"time_series_sanity_checks(tâ‚::AbstractVector{T}, xâ‚::AbstractVector{T}, Ïƒâ‚=nothing) where T\n\nPerform sanity checks on the time series. The function checks the following:\n\nThe time and value vectors have the same length\nThe time and uncertainty vectors have the same length\nThe time series are sorted in ascending order\nThe time series do not contain infinities or NaNs\n\nArguments\n\ntâ‚::AbstractVector{T}: time points of the time series\nxâ‚::AbstractVector{T}: values of the time series\nÏƒâ‚::AbstractVector{T}=nothing: uncertainty of the time series\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.ContinuumPowerSpectrum","page":"API Reference","title":"Tonari.ContinuumPowerSpectrum","text":"Abstract type for continuum power spectra, i.e. broadband noise power spectra with no features\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.DoubleBendingPowerLaw","page":"API Reference","title":"Tonari.DoubleBendingPowerLaw","text":" DoubleBendingPowerLaw(A, Î±â‚, fâ‚, Î±â‚‚, fâ‚‚, Î±â‚ƒ)\n\nDouble bending power law model for the power spectral density\n\nA : the amplitude\nÎ±â‚: the first power law index\nfâ‚: the first bend frequency\nÎ±â‚‚: the second power law index\nfâ‚‚: the second bend frequency\nÎ±â‚ƒ: the third power law index\n\nmathcalP(f) =  Afrac(ffâ‚)^-Î±â‚1 + (f  fâ‚)^Î±â‚‚ - Î±â‚frac11 + (f  fâ‚‚)^Î±â‚ƒ - Î±â‚‚\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.Lorentzian","page":"API Reference","title":"Tonari.Lorentzian","text":"Lorentzian(A, Î³, fâ‚€)\n\nLorentzian model for the power spectral density\n\nA: the amplitude\nÎ³: the width of the peak\nfâ‚€: the central frequency\n\nmathcalP(f) =  fracA4pi^2 (f - fâ‚€)^2 + Î³^2\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.PowerLaw","page":"API Reference","title":"Tonari.PowerLaw","text":" PowerLaw(Î±)\n\nPower law model for the power spectral density\n\nA: the power law amplitude\nÎ±: the power law index\n\nmathcalP(f) = A f^-Î±\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.PowerSpectralDensity","page":"API Reference","title":"Tonari.PowerSpectralDensity","text":"Abstract type for power spectral densities\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.QPO","page":"API Reference","title":"Tonari.QPO","text":"QPO(Sâ‚€, fâ‚€, Q)\n\nQPO model\n\nSâ‚€: the amplitude at the peak\nfâ‚€: the central frequency\nQ: quality factor\n\nmathcalP(f) =  fracS_0 f_0^4  left(f^ 2 -f_0^2right)^ 2 + f^2 f_0^2   Q^2 \n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.SingleBendingPowerLaw","page":"API Reference","title":"Tonari.SingleBendingPowerLaw","text":" SingleBendingPowerLaw(A, Î±â‚, fâ‚, Î±â‚‚)\n\nSingle bending power law model for the power spectral density\n\nA: the amplitude\nÎ±â‚: the first power law index\nfâ‚: the first bend frequency\nÎ±â‚‚: the second power law index\n\nmathcalP(f) =  A frac(ffâ‚)^-Î±â‚1 + (f  fâ‚)^Î±â‚‚ - Î±â‚\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.separate_psd-Tuple{PowerSpectralDensity}","page":"API Reference","title":"Tonari.separate_psd","text":" separate_psd(psd::PowerSpectralDensity)\n\nSeparate the PSD into its ContinuumPowerSpectrum components and other components if it is a sum of PSDs\n\nArguments\n\npsd::PowerSpectralDensity: power spectral density or sum of PowerSpectralDensity objects\n\nReturn\n\npsd_continuum::Union{SumOfPowerSpectralDensity,PowerSpectralDensity,nothing}: continuum part of the psd\npsd_line::Union{PowerSpectralDensity,nothing,Vector{PowerSpectralDensity}}: non-continuum part of the psd\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.Simulation","page":"API Reference","title":"Tonari.Simulation","text":"Simulation(model::Model, T::Real, Î”t::Real, S_high::Real, S_low::Real, t::AbstractVector{Real})\n\nA struct that contains the information of a simulation of a stochastic process.\n\nFields\n\nmodel::Model: The power spectral density of the process.\nT::Real: The duration of the simulated time series. Note that the time stamps are from 0 to T, so the duration is T.\nÎ”t::Real: The sampling period, or minimum time difference between samples.\nS_high::Real: The factor by which the maximum frequency is multiplied for the simulation.\nS_low::Real: The factor by which the minimum frequency is divided for the simulation.\nt::AbstractVector{Real}: The time vector, in this case, the time at which the process is sampled. It is assumed that the time vector is sorted.\n\nConstructors\n\nSimulation(model::Model, T::Real, Î”t::Real, S_high::Real, S_low::Real, t::AbstractVector{Real}): Constructs a simulation with regular sampling.\nSimulation(model::Model, T::Real, Î”t::Real): Constructs a simulation with regular sampling, and sets S_high and S_low to 10.0.\nSimulation(model::Model, T::Real, Î”t::Real, S_high::Real, S_low::Real): Constructs a simulation with the given parameters.\nSimulation(model::Model, t::AbstractVector{Real}, S_high::Real, S_low::Real): Constructs a simulation with sampling pattern given by t.\nSimulation(model::Model, t::AbstractVector{Real}): Constructs a simulation with sampling pattern given by t, and sets S_high and S_low to 10.0.\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsBase.sample","page":"API Reference","title":"StatsBase.sample","text":"sample(rng, sim, n=1, input_mean=0; Ïƒâ‚“ = nothing, split_long=false, randomise_values=true, Fvar=nothing, alt=false, poisson=false, exponentiate=false, error_size=0.02)\n\nGenerate a time series with a given power spectral density (PSD) using the (Timmer and KÃ¶nig, 1995) method.\n\nArguments\n\nrng::MersenneTwister: Random number generator.\nsim::Simulation: The simulation\nn::Int: Number of time series to generate. Default is 1.\ninput_mean::Real: The mean of the time series. Default is 0.\nÏƒâ‚“::Array{Float64, 1}: The errorbars of the time series. Default is nothing.\nsplit_long::Bool: If true, the time series is split into shorter time series given by sim.S_low-1. Default is true.\nrandomise_values::Bool: If true, the values of the time series are randomised. Default is true.\nFvar::Real: The variance of the time series. Default is nothing.\nalt::Bool: If true, uses the alternative Timmer & Koenig method. Default is false.\npoisson::Bool: If true, Poisson noise is added to the time series. Default is false.\nexponentiate::Bool: If true, the time series is exponentiated. Default is false.\nerror_size::Real: The size of the error. Default is 0.05.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.draw_errorbars","page":"API Reference","title":"Tonari.draw_errorbars","text":"draw_errorbars(rng, x, Î”t, poisson=false, error_size=0.05)\n\nDraw errorbars for the time series.\n\nArguments\n\nrng::MersenneTwister: Random number generator.\nx::Array{Float64, 1}: The values of the time series.\nÎ”t::Real: The sampling period.\npoisson::Bool: If true, Poisson noise is added to the time series. Default is false.\nerror_size::Real: The size of the error. Default is 0.05.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.findnearest-Tuple{Any, Any}","page":"API Reference","title":"Tonari.findnearest","text":"findnearest(a, b)\n\nFind the nearest value in b to each value in a. This assumes that a and b are sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.randomise_fluxes","page":"API Reference","title":"Tonari.randomise_fluxes","text":"randomise_fluxes(rng, xâ‚›, Î”t, input_mean = 0.0; Ïƒ = nothing, Fvar = nothing, poisson = false, exponentiate = false, error_size = 0.05)\n\nRandomise the fluxes of the time series.\n\nArguments\n\nrng::MersenneTwister: Random number generator.\nxâ‚›::Array{Float64, 1}: The values of the time series.\nÎ”t::Real: The sampling period.\ninput_mean::Real: The mean of the time series. Default is 0.\nÏƒ::Array{Float64, 1}: The errorbars of the time series. Default is nothing.\nFvar::Real: The variance of the time series. Default is nothing.\npoisson::Bool: If true, Poisson noise is added to the time series. Default is false.\nexponentiate::Bool: If true, the time series is exponentiated. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.sample_split_timeseries-NTuple{7, Any}","page":"API Reference","title":"Tonari.sample_split_timeseries","text":"sample_split_timeseries(x, t, t_desired, n_sim, n, n_slices, split_long)\n\nSplit the time series into shorter time series and sample at the desired time stamps.\n\nArguments\n\nx::Array{Float64, 1} or Vector{Matrix{Float64}}: The values of the time series. If there are multiple bands, the time series is a vector of matrices.\nt::Array{Float64, 1}: The time indexes of the time series.\nt_desired::Array{Float64, 1}: The desired time stamps.\nn_sim::Int: The number of simulations.\nn::Int: The number of time series to generate.\nn_slices::Int: The number of slices to break the time series into.\nsplit_long::Bool: If true, the time series is split into shorter time series. Default is true.\n\nReturns\n\nA tuple of two arrays: the first containing the time indexes of the shorter time series, and the second containing the values of the shorter time series.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.sample_timeseries-Tuple{Any, Any}","page":"API Reference","title":"Tonari.sample_timeseries","text":"sample_timeseries(t, y, M)\n\nExtract a random subset of points from the time series.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.split_longtimeseries-Tuple{Any, Any, Int64, Any}","page":"API Reference","title":"Tonari.split_longtimeseries","text":"split_longtimeseries(t, ts, n_slices, t_end)\n\nSplit a long time series into shorter time series. Break the time series into n_slices shorter time series. The short time series are of equal length.\n\nArguments\n\nt: The time indexes of the long time series.\nts: The values of the long time series.\nn_slices: The number of slices to break the time series into.\nt_end\n\nReturns\n\nA tuple of two lists: the first containing the time indexes of the shorter time series, and the second containing the values of the shorter time series.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.timmer_koenig-Tuple{Any, Random.AbstractRNG}","page":"API Reference","title":"Tonari.timmer_koenig","text":"timmer_koenig(psd, rng::random.AbstractRNG, alternative=false)\n\nGenerate a time series with a given power spectral density (PSD) using the (Timmer and KÃ¶nig, 1995) method\n\nGiven N values of the power spectral density (PSD) ð“Ÿ\nDraw 2N values from a standard normal distribution.\nThe amplitude of the randomised periodogram is given by A = N + i M\nThe randomised periodogram is given by ð“Ÿ_rand = âˆš(ð“Ÿ / 2) * A\nThe first value of the randomised periodogram inserted and set to 0\nThe time series is obtained by taking the inverse Fourier transform of the randomised periodogram, with the function FFTW.irfft. We use the length of the time series as 2*(N+1)-1.\n\nThe alternative parametrisation is given by\n\nGiven N values of the power spectral density (PSD) ð“Ÿ\nDraw N-1 values from a Ï‡Â²(2)  distribution and 1 value from Ï‡Â²â‚(1), this is A the amplitude of the randomised periodogram\nDraw N values from a uniform distribution between 0 and 1, and set the last value to 0, this is Î¸ the phase of the randomised periodogram\nThe randomised periodogram is given by ð“Ÿ_rand = âˆš(ð“Ÿ / 2 * A) * exp(2Ï€iÎ¸)\nThe first value of the randomised periodogram inserted and set to 0\nThe time series is obtained by taking the inverse Fourier transform of the randomised periodogram, with the function FFTW.irfft. We use the length of the time series as 2*(N+1)-1.\n\nArguments\n\nð“Ÿ::Array{Float64, 1}: PSD associated with the process\nrng::Random.AbstractRNG: Random number generator.\nÎ±::Real: Multiplicative factor for the randomised periodogram. Default is 1.0. This can be a complex vector to add a phase to the time series.\n\nReturns\n\nx::Array{Float64, 1}: Time series with the given PSD.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.coherence","page":"API Reference","title":"Tonari.coherence","text":"coherence(f, CÌ„, PÌ„â‚, PÌ„â‚‚, n_segments, yâ‚_err = nothing, yâ‚‚_err = nothing)\n\nCompute the coherence between two time series defined in (Vaughan and Nowak, 1997) using the cross-periodogram CÌ„, the mean power spectrum of the first time series PÌ„â‚, and the mean power spectrum of the second time series PÌ„â‚‚. The coherence is defined as:\n\ngamma^2 (f) = fracoverlineC(f)^2overlineP_1(f) overlineP_2(f)\n\nwith the error in the coherence given by:\n\nsigma_gamma^2 = sqrt2 sqrtgamma^2 frac1 - gamma^2sqrtM\n\nwhere M is the number of segments over which the coherence is computed.\n\nThe phase lag is defined as:\n\nDelta phi (f) = arg overlineC(f)\n\nwith the error in the phase lag given by:\n\nsigma_Delta phi = frac1 - gamma^2sqrt2 gamma^2 M\n\nThe time lag is defined as:\n\nDelta tau (f) = fracDelta phi2 pi f\n\nwith the error in the time lag given by:\n\nsigma_Delta tau = fracsigma_Delta phi2 pi f\n\nIf the errors in the time series are provided, the corrected coherence is computed using the method described in (Vaughan and Nowak, 1997).\n\nArguments\n\nf::Array{Float64, 1}: Frequency array.\nCÌ„::Array{Complex{Float64}, 1}: Cross-periodogram.\nPÌ„â‚::Array{Float64, 1}: Mean power spectrum of the first time series.\nPÌ„â‚‚::Array{Float64, 1}: Mean power spectrum of the second time series.\nn_segments::Int: Number of segments over which the coherence is computed.\nyâ‚_err::Array{Float64, 1}: Error in the first time series.\nyâ‚‚_err::Array{Float64, 1}: Error in the second time series.\n\nif the errors in the time series are not provided, the function returns the coherence, phase lag, and time lag. Otherwise, it returns the corrected coherence, phase lag, and time lag.\n\nReturns\n\nf::Array{Float64, 1}: Frequency array.\nÎ³Â²::Array{Float64, 1}: Coherence.\nÎ”Ï†::Array{Float64, 1}: Phase lag.\nÎ³Â²_err::Array{Float64, 1}: Error in the coherence.\nÎ”Ï†_err::Array{Float64, 1}: Error in the phase lag.\nÎ”Ï„::Array{Float64, 1}: Time lag.\nÎ”Ï„_err::Array{Float64, 1}: Error in the time lag.\nPÌ„â‚::Array{Float64, 1}: Mean power spectrum of the first time series.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.cross_periodogram","page":"API Reference","title":"Tonari.cross_periodogram","text":"cross_periodogram(t, yâ‚, yâ‚‚, yâ‚_err = nothing, yâ‚‚_err = nothing; compute_coherence = true, apply_end_matching = false, subtract_mean = true)\n\nCompute the cross-periodogram between two time series yâ‚ and yâ‚‚ with time stamps t using the fast Fourier transform (FFT).\n\nArguments\n\nt::Array{Float64, 1}: Time stamps.\nyâ‚::Array{Float64, 1}: First time series data. Or a matrix of multiple time series.\nyâ‚‚::Array{Float64, 1}: Second time series data. Or a matrix of multiple time series.\nyâ‚_err::Array{Float64, 1}: Error in the first time series. Or a matrix of errors for multiple time series.\nyâ‚‚_err::Array{Float64, 1}: Error in the second time series Or a matrix of errors for multiple time series.\ncompute_coherence::Bool: Compute the coherence between the two time series. Default is true.\napply_end_matching::Bool: Apply end-matching to the data. Default is false.\nsubtract_mean::Bool: Subtract the mean from the data. Default is true.\n\nIf compute_coherence  is true, the function returns the coherence between the two time series. Otherwise, it returns the cross-periodogram and the mean power spectra of the two time series. see coherence function for the optional returns.\n\nReturns\n\nf::Array{Float64, 1}: Frequency array.\nCÌ„::Array{Complex{Float64}, 1}: Mean cross-periodogram.\nPÌ„â‚::Array{Float64, 1}: Mean power spectrum of the first time series.\nPÌ„â‚‚::Array{Float64, 1}: Mean power spectrum of the second time series.\nC::Array{Complex{Float64}, 1}: Cross-periodogram.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.end_matching-Tuple{Any, Any}","page":"API Reference","title":"Tonari.end_matching","text":"end_matching(y,t)\n\nEnd-match the data y with a straight line and subtract it from the data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.periodogram","page":"API Reference","title":"Tonari.periodogram","text":"periodogram(t,y, normalisation = \"default\"; apply_end_matching = false, subtract_mean = true)\n\nCompute the periodogram of the data y with time stamps t using the fast Fourier transform (FFT).\n\nThe periodogram is computed as the squared magnitude of the Fourier transform of the data. In practrice we use the real-valued fast Fourier transform (rfft) to compute the periodogram.\n\nArguments\n\nt::Array{Float64, 1}: Time stamps.\ny::Array{Float64, 1}: Time series data.\nnormalisation::Float64: Normalisation factor. Default is 2Î”t / length(t).\napply_end_matching::Bool: Apply end-matching to the data. Default is false.\nsubtract_mean::Bool: Subtract the mean from the data. Default is true.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.cross_correlate-Union{Tuple{T}, Tuple{Random.AbstractRNG, Vararg{AbstractVector{T}, 4}}} where T","page":"API Reference","title":"Tonari.cross_correlate","text":"cross_correlate(tâ‚::AbstractVector{T}, xâ‚::AbstractVector{T}, tâ‚‚::AbstractVector{T}, xâ‚‚::AbstractVector{T}; Ïƒâ‚=nothing, Ïƒâ‚‚=nothing, Ï„_list=nothing, Î”Ï„=nothing, max_lag=nothing, local_estimate=false, both_ways=true, method=\"iccf\", compute_errors=false, peak_frac=0.8, bootstrap=false, n_simulations=1_000,\nskip_sanity_checks = false) where T\n\nCompute the cross-correlation function between two time series.\n\nThe function computes the cross-correlation function between two time series by linearly interpolating the second time series using the interpolated cross-correlation function (ICCF) method. Most of this code is based on the R package sour by Simon Vaughan, University of Leicester https://github.com/SimonVaughanDataAndCode/sour.\n\nArguments\n\ntâ‚::AbstractVector{T}: time stamps of the first time series\nxâ‚::AbstractVector{T}: values of the first time series\ntâ‚‚::AbstractVector{T}: time stamps of the second time series\nxâ‚‚::AbstractVector{T}: values of the second time series\n\nOptional arguments\n\nÏƒâ‚::AbstractVector{T} = nothing: uncertainty of the first time series\nÏƒâ‚‚::AbstractVector{T} = nothing: uncertainty of the second time series\nÏ„_list::AbstractVector{T} = nothing: list of time lags, if not provided, it will be computed based on the time range of the time series\nÎ”Ï„::T = nothing: time step between the time lags\nmax_lag::T = nothing: maximum time lag\nlocal_estimate::Bool = false: flag to estimate the local mean and standard deviation of the time series\nboth_ways::Bool = true: Compute the cross-correlation function in both ways, i.e., from the first to the second time series and from the second to the first time series\nmethod::String = \"iccf\": method to compute the cross-correlation function\ncompute_errors::Bool = false: flag to compute the errors of the cross-correlation function\npeak_frac::T = 0.8: fraction of the peak to integrate to get the lag\nbootstrap::Bool = false: flag to compute the errors using bootstrapping\nn_simulations::Int = 1_000: number of simulations to compute the errors\nskip_sanity_checks::Bool = false: flag to skip the sanity checks\n\nReturns\n\nÏ„_list::AbstractVector{T}: list of time lags\nr::AbstractVector{T}: cross-correlation function\nq::AbstractVector{T}: Distribution of centroid lags if compute_errors is true\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.get_lag_list-NTuple{5, Any}","page":"API Reference","title":"Tonari.get_lag_list","text":"get_lag_list(Î”Ï„, max_lag,tâ‚,tâ‚‚,Ï„_list)\n\nGet the list of time lags to compute the cross-correlation function.\n\nArguments\n\nÎ”Ï„::T: time step between the time lags\nmax_lag::T: maximum time lag\ntâ‚::AbstractVector{T}: time stamps of the first time series\ntâ‚‚::AbstractVector{T}: time stamps of the second time series\nÏ„_list::AbstractVector{T}: list of time lags\n\nReturns\n\nÏ„_list::AbstractVector{T}: list of time lags\nÎ”Ï„::T: time step between the time lags\nmax_lag::T: maximum time lag\nn_lags::Int64: number of time lags\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.iccf-Union{Tuple{T}, NTuple{5, AbstractVector{T}}} where T","page":"API Reference","title":"Tonari.iccf","text":"iccf(tâ‚::AbstractVector{T}, xâ‚::AbstractVector{T}, tâ‚‚::AbstractVector{T}, xâ‚‚::AbstractVector{T}, Ï„_list::AbstractVector{T} ; local_estimate=false) where T\n\nCompute the interpolated cross-correlation function (ICCF) between two time series.\n\nThe function computes the cross-correlation function between two time series by linearly interpolating the second time series on the time points of the first time series. The ICCF is presented in Edelson et al. 2017  https://ui.adsabs.harvard.edu/abs/2017ApJ...840...41E/abstract and Peterson et al. 2004 https://ui.adsabs.harvard.edu/abs/2004ApJ...613..682P/abstract. The current implementation is based on the R package sour by Simon Vaughan, University of Leicester https://github.com/SimonVaughanDataAndCode/sour.\n\nhttps://ui.adsabs.harvard.edu/abs/1986ApJ...305..175G/abstract\n\nArguments\n\ntâ‚::AbstractVector{T}: time points of the first time series\nxâ‚::AbstractVector{T}: values of the first time series\ntâ‚‚::AbstractVector{T}: time points of the second time series\nxâ‚‚::AbstractVector{T}: values of the second time series\nÏ„_list::AbstractVector{T}: list of time lags\nlocal_estimate::Bool=false: flag to estimate the local mean and standard deviation of the time series\n\nReturns\n\nCCF::Vector{T}: cross-correlation function\nnx::Vector{Int64}: number of points in each time lag bin\n\nExample\n\nusing Random\nRandom.seed!(123)\ntâ‚ = 0:0.1:10\nxâ‚ = randn(length(tâ‚))\ntâ‚‚ = 0:0.1:10\nxâ‚‚ = randn(length(tâ‚‚))\nÏ„_list = -10:0.1:10\nCCF,nx = iccf(tâ‚, xâ‚, tâ‚‚, xâ‚‚, Ï„_list)\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.iccf_errors-Union{Tuple{T}, Tuple{Random.AbstractRNG, Vararg{AbstractVector{T}, 4}}} where T","page":"API Reference","title":"Tonari.iccf_errors","text":"iccf_errors(rng::AbstractRNG, tâ‚::AbstractVector{T}, xâ‚::AbstractVector{T}, tâ‚‚::AbstractVector{T}, xâ‚‚::AbstractVector{T}, Ïƒâ‚::AbstractVector{T} = nothing, Ïƒâ‚‚::AbstractVector{T} = nothing,peak_frac = 0.8,local_estimate = false,Ï„_list = nothing,bootstrap = false,n_simulations = 1_000) where {T}\n\nCompute the errors of the interpolated cross-correlation function (ICCF) between two time series.\n\nArguments\n\nrng::AbstractRNG: Random number generator\ntâ‚::AbstractVector{T}: time points of the first time series\nxâ‚::AbstractVector{T}: values of the first time series\ntâ‚‚::AbstractVector{T}: time points of the second time series\nxâ‚‚::AbstractVector{T}: values of the second time series\nÏƒâ‚::AbstractVector{T} = nothing: uncertainty of the first time series\nÏƒâ‚‚::AbstractVector{T} = nothing: uncertainty of the second time series\npeak_frac::T = 0.8: fraction of the peak to integrate to get the lag\nlocal_estimate::Bool = false: flag to estimate the local mean and standard deviation of the time series\nÏ„_list::AbstractVector{T} = nothing: list of time lags\nbootstrap::Bool = false: flag to compute the errors using bootstrapping\nn_simulations::Int = 1_000: number of simulations to compute the errors\n\nReturns\n\nq::Vector{T}: array of lags\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.randomise_lc_flux-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, AbstractVector{T}}} where T","page":"API Reference","title":"Tonari.randomise_lc_flux","text":"randomise_lc_flux(rng::AbstractRNG, t::Vector{Float64}, x::Vector{Float64}; Ïƒ::Vector{Float64} = nothing, bootstrap::Bool = false)\n\nRandomise the light curve by sampling with replacement. If bootstrap is true, the errors are not added to the light curve.\n\nArguments\n\nrng::AbstractRNG: Random number generator\nt::Vector{Float64}: Time array\nx::Vector{Float64}: Flux array\nÏƒ::Vector{Float64}: Error array\nbootstrap::Bool: If true, the errors are not added to the light curve\n\nReturns\n\nt_samp::Vector{Float64}: Sampled time array\nx_samp::Vector{Float64}: Sampled flux array\nÏƒ_samp::Vector{Float64}: Sampled error array\n\n\n\n\n\n","category":"method"},{"location":"periodogram/#Periodogram-computation","page":"Periodogram computation","title":"Periodogram computation","text":"The periodogram is an estimator for the power spectral density of a time series. It is defined as the squared magnitude of the discrete Fourier transform of the time series. We use FFTW.jl to compute the discrete Fourier transform efficiently:\n\nX(f) = sum_n=1^N x_n e^-2pi i f n Delta t\n\nwhere x_n is the time series , f is the frequency, and Delta t is the time interval between data points. The periodogram is then defined as\n\nI(f) = frac2T X(f)^2\n\nwhere T=NDelta t is the total duration of the time series. The periodogram is an unbiased estimator of the power spectral density.\n\nusing Tonari\nusing Random\nusing Plots\nusing StatsBase\nrng = MersenneTwister(1234)\n\nLet's start by simulating time series data with a single bending power law power spectral density model.\n\npsd_model = SingleBendingPowerLaw(1.0, 1.13, 1.2e-1, 4.22)\nf = 10.0 .^ range(-3, stop=2, length=1000)\npsd = psd_model(f)\nT, Î”t = 504.2, 0.12\nsimu = Simulation(psd_model, T, Î”t)\nt, x, Ïƒ = sample(rng, simu, 10, error_size = 0.25)\n\nWe compute the average periodogram of the time series data using the function periodogram. It is common to subtract the mean of the time series before computing the periodogram. The function also allows for applying end-matching, which is useful for reducing spectral leakage when the first and last points of the time series are not close to each other in value.\n\nf,I = periodogram(t,x,apply_end_matching=false)\n\nWe can compare the periodogram to the model power spectral density. The noise level is given by 2Delta t times textmean(sigma^2), where sigma is the error on the time series data. See Appendix A of (Vaughan et al., 2003) for other normalisations and noise levels.\n\nnoise_level = 2Î”t*mean(Ïƒ.^2)\n\nfx = 10.0 .^ range(-3, stop=0.5, length=1000)\nplot(f,I,yscale=:log10,xscale=:log10,xlabel=\"Frequency (Hz)\",ylabel=\"Power\",label=\"Periodogram\",framestyle=:box)\nplot!(fx,psd_model(fx),label=\"Model\",linewidth=2)\nhline!([noise_level],label=\"Noise level\",linewidth=2,linestyle=:dash)","category":"section"},{"location":"correlations/#Lag-and-correlations-between-two-time-series","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"The lag and correlation functions are useful for understanding the relationship between two time series. Here we show how to compute the lag and correlation functions using the interpolated cross-correlation function (ICCF).","category":"section"},{"location":"correlations/#Interpolated-cross-correlation-function-(ICCF)","page":"Lag and correlations between two time series","title":"Interpolated cross-correlation function (ICCF)","text":"","category":"section"},{"location":"correlations/#Explanation","page":"Lag and correlations between two time series","title":"Explanation","text":"As its name suggests, the interpolated cross-correlation function, is the cross-correlation function calculated on interpolated data. In astronomy, most long-term time series of quasars are often irregularly sampled due to observation constraints, seasons, weather, etc.\n\nThe seminal paper on the ICCF is Gaskell and Sparke (1986) where linear interpolation is used. Peterson et al. (1998) introduced flux-randomisation and ressampling to estimate uncertainties on the delay measurement.\n\nThis package is a Julia reimplementation of the R package sour written by Simon Vaughan https://github.com/SimonVaughanDataAndCode/sour/ and applied in Edelson et al. (2017).","category":"section"},{"location":"correlations/#Example","page":"Lag and correlations between two time series","title":"Example","text":"Let's simulate a pair of time series with a known cross-spectral density and compute the ICCF. The ICCF is a method to estimate the cross-correlation function between two time series with different sampling rates. The ICCF is computed by interpolating the cross-correlation function between the two time series.\n\nusing Plots,Tonari,Random\n\nrng = MersenneTwister(4)\n\np1 = SingleBendingPowerLaw(1.0, 0.63, 10.0e-2, 3.22)\np2 = SingleBendingPowerLaw(1.0, 0.78, 13.0e-2, 4.81)\nÎ”Ï• = ConstantTimeLag(18.5)\ncs = CrossSpectralDensity(p1, p2, Î”Ï•)\n\nT, Î”t = 404.2, 0.1\nsimu = Simulation(cs, T, Î”t)\nt, y, yerr = sample(rng, simu, 1, error_size = 0.05)\nN1, N2 = 511, 680\n# sample indices\np1 = sort(sample(rng, 1:length(t), N1, replace = false))\np2 = sort(sample(rng, 1:length(t), N2, replace = false))\n\ntâ‚, yâ‚, Ïƒâ‚ = t[p1], y[1][p1, 1], yerr[1][p1, 1]\ntâ‚‚, yâ‚‚, Ïƒâ‚‚ = t[p2], y[2][p2, 1], yerr[2][p2, 1]\n\nplot(tâ‚, yâ‚, yerr=Ïƒâ‚, label=\"Time series 1\", xlabel=\"Time\", ylabel=\"Flux\", title=\"Time series 1 and 2\")\nplot!(tâ‚‚, yâ‚‚, yerr=Ïƒâ‚‚, label=\"Time series 2\")\n\nWe can compute the ICCF using the cross_correlate function. The function returns the cross-correlation function, the time lags, and the centroid of the cross-correlation function from Monte Carlo simulations of the input time series.\n\nÏ„_list, r, q = cross_correlate( tâ‚, yâ‚, tâ‚‚, yâ‚‚, Ïƒâ‚ = Ïƒâ‚, Ïƒâ‚‚ = Ïƒâ‚‚,max_lag=150,Î”Ï„=1, compute_errors = true, n_simulations = 1000)\nplot(Ï„_list, r, label=\"ICCF\", xlabel=\"Time Lag\", ylabel=\"Correlation\", title=\"Interpolated cross-correlation function\")\n\nWe can compute the centroid of the ICCF and plot it as a vertical line.\n\nm = r .>=0.8*maximum(r)\nÏ„_cent = sum(Ï„_list[m].*r[m])/sum(r[m])\n\nWe can plot the distribution of the centroid of the ICCF and use it for error estimation.\n\np = histogram(q, bins=50, label=\"Time Lag ICCF Centroid\", xlabel=\"Time Lag \", ylabel=\"Frequency\",)\np = vline!([Ï„_cent], label=\"Lag centroid\")","category":"section"},{"location":"correlations/#Discrete-Correlation-function-(DCF)","page":"Lag and correlations between two time series","title":"Discrete Correlation function (DCF)","text":"Not implemented yet. Edelson and Krolik (1988)","category":"section"},{"location":"#Tonari","page":"Home","title":"Tonari","text":"Tonari is a Julia package for time series analysis with an emphasis on astronomical applications. It contains simple power spectral density models like SingleBendingPowerLaw for quasar variability studies.\n\nPages = [\"index.md\",\"simulations.md\",\"simulations_delays.md\",\"periodogram.md\", \"correlations.md\",\"references.md\", \"api.md\"]\nDepth = 2","category":"section"},{"location":"simulations/#Simulating-univariate-time-series","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Let's simulate univariate time series data from a power spectrum model using the method of (Timmer and KÃ¶nig, 1995). First we need to load the Tonari package and the Random package for generating random numbers.\n\nusing Tonari\nusing Random\nusing Plots\nusing StatsBase\n\nLet's define the power spectrum model, for instance we will use SingleBendingPowerLaw.\n\npsd_model = SingleBendingPowerLaw(1.0, 1.13, 1.2e-1, 4.22)\nf = 10.0 .^ range(-3, stop=2, length=1000)\npsd = psd_model(f)\nplot(f, psd, xscale=:log10, yscale=:log10, xlabel=\"Frequency\", ylabel=\"Power Spectrum Density\", label=\"Power Spectrum\", framestyle=:box)","category":"section"},{"location":"simulations/#Regularly-sampled-data","page":"Simulating univariate time series","title":"Regularly sampled data","text":"Now we can simulate the time series data. We first define a Simulation struct with the power spectrum model,the total time T, the time step Î”t, the mean count rate Î¼, and the variance ÏƒÂ². We can also add the S_low and S_high parameters to the simulation object. The S_low and S_high parameters are factors that extend the grid of frequencies. This is useful to avoid the cyclic effect of the discrete Fourier transform, the resulting time series is extracted from a longer time interval.\n\n\nT, Î”t = 504.2, 0.132\nsimu = Simulation(psd_model, T, Î”t, 10, 10)\n\nNow we can simulate the time series data by sampling the generative model.\n\nrng = MersenneTwister(42)\nN = 10\nt, x, Ïƒ = sample(rng, simu, N, error_size = 0.25)\n\nnote: Note\nThe split_long parameter is used to split the long time series into smaller segments to speed up the computation, by default this is enabled. This is useful when we want to simulate a large number of time series.\n\nFinally, we can plot the simulated time series data.\n\nscatter(t, x[:, 1], label = nothing, yerr = Ïƒ[:, 1], xlabel = \"Time (days)\", ylabel = \"Value\", framestyle = :box, ms = 2)\n\nWe can check that the simulated time series data has the same power spectrum as the model.\n\nf,I = periodogram(t,x,apply_end_matching=false,subtract_mean=true)\nnoise_level = 2Î”t*mean(Ïƒ.^2)\nfx = 10.0 .^ range(-3, stop=0.5, length=1000)\nplot(f,I,yscale=:log10,xscale=:log10,xlabel=\"Frequency (Hz)\",ylabel=\"Power\",label=\"Periodogram\",framestyle=:box)\nplot!(fx,psd_model(fx),label=\"Model\",linewidth=2)\nhline!([noise_level],label=\"Noise level\",linewidth=2,linestyle=:dash)","category":"section"},{"location":"simulations/#Irregularly-sampled-data","page":"Simulating univariate time series","title":"Irregularly sampled data","text":"We can also simulate irregularly sampled data. We first need to define the time stamps t. Let's draw the times from a uniform distribution.\n\nt = sort(sample(rng,collect(0:Î”t:T),150,replace=false))\n\nWe now define the Simulation object  with the new time stamps.\n\nsimu = Simulation(psd_model, t, 10, 10)\n\nWe can now sample the generative model.\n\nt_obs, x, Ïƒ = sample(rng, simu, error_size = 0.25)\nscatter(t_obs, x, label = nothing, yerr = Ïƒ, xlabel = \"Time (days)\", ylabel = \"Value\", framestyle = :box, ms = 2)","category":"section"},{"location":"simulations/#With-custom-errorbars","page":"Simulating univariate time series","title":"With custom errorbars","text":"It is possible to give the errorbars to randomise the data. The errorbars are given as a vector of the same length as the time stamps.\n\nsimu = Simulation(psd_model, t)\nÏƒs = 0.1 .+ 0.1 * rand(rng, length(t_obs))\n\nt_obs, x, Ïƒ = sample(rng, simu, Ïƒâ‚“=Ïƒs)\n@assert Ïƒ==Ïƒs\nscatter(t_obs, x, label = nothing, yerr = Ïƒs, xlabel = \"Time (days)\", ylabel = \"Value\", framestyle = :box, ms = 2)","category":"section"}]
}
