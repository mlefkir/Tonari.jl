var documenterSearchIndex = {"docs":
[{"location":"simulations_delays/#Simulating-delayed-time-series","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"","category":"section"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"Let's simulate two time series with a delay ","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"using Tonari\nusing Random\nusing Plots\nusing StatsBase\nrng = MersenneTwister(42)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"Let's define the individual power spectral densities and the phase delay. We will use two bending power laws and a constant time delay.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"p1 = SingleBendingPowerLaw(1.0, 0.63, 10e-2, 3.22)\np2 = SingleBendingPowerLaw(1.0, 0.78, 13e-2, 3.81)\nΔϕ = ConstantTimeLag(12.35)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"The cross-spectral density is defined by the two power spectral densities and the phase delay.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"cs = CrossSpectralDensity(p1, p2, Δϕ)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"We can now simulate the time series using the Simulation type.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"T, Δt = 504.2, 0.133\nsimu = Simulation(cs, T, Δt)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"and sample 50 time series.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"t, y, yerr = sample(rng,simu,50,error_size=0.15)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"scatter(t,y[1][:,1],yerr=yerr[1][:,1],label=\"1\", framestyle=:box)\nscatter!(t,y[2][:,1],yerr=yerr[2][:,1],label=\"2\", framestyle=:box, xlabel=\"Time (days)\", ylabel=\"Value\")","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"The cross periodogram can be computed using the cross_periodogram function. γ² is the coherence, Δφ the phase difference and Δτ the time delay.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"f, γ², γ²_corrected, Δφ, γ²_err, γ²_corrected_err, Δφ_err, Δτ, Δτ_err, P̄₁, P̄₂, N₁, N₂, n = cross_periodogram(t, y[1], y[2], yerr[1],yerr[2])","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"The individual periodograms can be plotted:","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"plot(f,P̄₁,label=\"P₁\")\nplot!(f,P̄₂,xscale=:log10,yscale=:log10,label=\"P₂\",xlabel=\"Frequency (d^-1)\",ylabel=\"Power\")\nhline!([N₁,N₂],linestyle=:dash,label=\"noise level\", framestyle=:box)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"The coherence and the phase difference can be plotted as a function of the frequency:","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"l = @layout [a; b]\np1 = scatter(f, γ²_corrected, yerr=γ²_corrected_err, label=\"γ² corrected\",marker=:square,ms=4,xscale=:log10,size=(800,400))\np1 = scatter!(f, γ², yerr=γ²_err, label=\"γ²\", xscale=:log10,ylims=(0,1.1),ms=4,ylabel=\"Coherence\",link=:x, framestyle=:box)\np2 = scatter(f, Δτ, yerr=Δτ_err, xscale=:log10, ylabel=\"Time delay (d)\",xlabel=\"Frequency (d^-1)\",link=:x, framestyle=:box,label=nothing)\np2 = hline!([Δϕ.Δτ ],color=:black,label=\"True delay\")\nplot(p1, p2, layout=l,size=(800,600))","category":"page"},{"location":"simulations_delays/#With-a-constant-phaselag","page":"Simulating delayed time series","title":"With a constant phaselag","text":"","category":"section"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"p1 = SingleBendingPowerLaw(1.0, 0.63, 10e-2, 3.22)\np2 = SingleBendingPowerLaw(1.0, 0.78, 13e-2, 3.81)\nΔϕ = ConstantPhaseLag(56.2,5*1/T)\n\ncs = CrossSpectralDensity(p1, p2, Δϕ)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"T, Δt = 504.2, 0.133\nsimu = Simulation(cs, T, Δt)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"t, y, yerr = sample(rng,simu,50,error_size=0.15)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"scatter(t,y[1][:,1],yerr=yerr[1][:,1],label=\"1\", framestyle=:box)\nscatter!(t,y[2][:,1],yerr=yerr[2][:,1],label=\"2\", framestyle=:box, xlabel=\"Time (days)\", ylabel=\"Value\")","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"f, γ², γ²_corrected, Δφ, γ²_err, γ²_corrected_err, Δφ_err, Δτ, Δτ_err, P̄₁, P̄₂, N₁, N₂, n = cross_periodogram(t, y[1], y[2], yerr[1],yerr[2])","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"plot(f,P̄₁,label=\"P₁\")\nplot!(f,P̄₂,xscale=:log10,yscale=:log10,label=\"P₂\",xlabel=\"Frequency (d^-1)\",ylabel=\"Power\")\nhline!([N₁,N₂],linestyle=:dash,label=\"noise level\", framestyle=:box)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"l = @layout [a; b ; c]\np1 = scatter(f, γ²_corrected, yerr=γ²_corrected_err, label=\"γ² corrected\",marker=:square,ms=4,xscale=:log10,size=(800,400))\np1 = scatter!(f, γ², yerr=γ²_err, label=\"γ²\", xscale=:log10,ylims=(0,1.1),ms=4,ylabel=\"Coherence\",link=:x, framestyle=:box)\n\np2 = scatter(f, Δφ, yerr=Δφ_err, xscale=:log10, ylabel=\"Time delay (d)\",xlabel=\"Frequency (d^-1)\",link=:x, framestyle=:box,label=nothing)\np2 = plot!(f,calculate(Δϕ,f) .* 2 .*pi .* f )\nprintln(calculate(Δϕ,f[1]) .* 2 .*pi .* f[1] )\n\np3 = scatter(f, Δτ, yerr=Δτ_err, xscale=:log10, ylabel=\"Time delay (d)\",xlabel=\"Frequency (d^-1)\",link=:x, framestyle=:box,label=nothing)\np3 = plot!(f,-calculate(Δϕ,f) )\n\nplot(p1, p2,p3, layout=l,size=(800,900))","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Timmer, J. and König, M. (1995). On generating power law noise. aap 300, 707.\n\n\n\nVaughan, B. A. and Nowak, M. A. (1997). X-Ray Variability Coherence: How to Compute It, What It Means, and How It Constrains Models of GX 339-4 and Cygnus X-1, apjl 474, L43-L46, arXiv:astro-ph/9610257 [astro-ph].\n\n\n\nVaughan, S.; Edelson, R.; Warwick, R. and Uttley, P. (2003). On characterizing the variability properties of X-ray light curves from active galaxies, mnras 345, 1271–1284, arXiv:astro-ph/0307420 [astro-ph].\n\n\n\n","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Models","page":"API Reference","title":"Models","text":"","category":"section"},{"location":"api/#Power-spectral-densities","page":"API Reference","title":"Power spectral densities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Tonari]\nPages = [\"psd.jl\"]\nPrivate = false\nOrder   = [:type, :function]","category":"page"},{"location":"api/#Tonari.DoubleBendingPowerLaw","page":"API Reference","title":"Tonari.DoubleBendingPowerLaw","text":" DoubleBendingPowerLaw(α₁, f₁, α₂, f₂, α₃)\n\nDouble bending power law model for the power spectral density\n\nα₁: the first power law index\nf₁: the first bend frequency\nα₂: the second power law index\nf₂: the second bend frequency\nα₃: the third power law index\n\nmathcalP(f) =  Afrac(ff₁)^-α₁1 + (f  f₁)^α₂ - α₁frac11 + (f  f₂)^α₃ - α₂\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.Lorentzian","page":"API Reference","title":"Tonari.Lorentzian","text":"Lorentzian(A, γ, f₀)\n\nLorentzian model for the power spectral density\n\nA: the amplitude\nγ: the width of the peak\nf₀: the central frequency\n\nmathcalP(f) =  fracA4pi^2 (f - f₀)^2 + γ^2\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.SingleBendingPowerLaw","page":"API Reference","title":"Tonari.SingleBendingPowerLaw","text":" SingleBendingPowerLaw(A, α₁, f₁, α₂)\n\nSingle bending power law model for the power spectral density\n\nA: the amplitude\nα₁: the first power law index\nf₁: the first bend frequency\nα₂: the second power law index\n\nmathcalP(f) =  A frac(ff₁)^-α₁1 + (f  f₁)^α₂ - α₁\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulations","page":"API Reference","title":"Simulations","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Tonari]\nPages = [\"simulate.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"api/#Tonari.Simulation","page":"API Reference","title":"Tonari.Simulation","text":"Simulation(model::Model, T::Real, Δt::Real, S_high::Real, S_low::Real, t::AbstractVector{Real})\n\nA struct that contains the information of a simulation of a stochastic process.\n\nFields\n\nmodel::Model: The power spectral density of the process.\nT::Real: The duration of the simulated time series. Note that the time stamps are from 0 to T, so the duration is T.\nΔt::Real: The sampling period, or minimum time difference between samples.\nS_high::Real: The factor by which the maximum frequency is multiplied for the simulation.\nS_low::Real: The factor by which the minimum frequency is divided for the simulation.\nt::AbstractVector{Real}: The time vector, in this case, the time at which the process is sampled. It is assumed that the time vector is sorted.\n\nConstructors\n\nSimulation(model::Model, T::Real, Δt::Real, S_high::Real, S_low::Real, t::AbstractVector{Real}): Constructs a simulation with regular sampling.\nSimulation(model::Model, T::Real, Δt::Real): Constructs a simulation with regular sampling, and sets S_high and S_low to 10.0.\nSimulation(model::Model, T::Real, Δt::Real, S_high::Real, S_low::Real): Constructs a simulation with the given parameters.\nSimulation(model::Model, t::AbstractVector{Real}, S_high::Real, S_low::Real): Constructs a simulation with sampling pattern given by t.\nSimulation(model::Model, t::AbstractVector{Real}): Constructs a simulation with sampling pattern given by t, and sets S_high and S_low to 10.0.\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsBase.sample","page":"API Reference","title":"StatsBase.sample","text":"sample(rng, sim, n=1, input_mean=0; σₓ = nothing, split_long=false, randomise_values=true, Fvar=nothing, alt=false, poisson=false, exponentiate=false, error_size=0.02)\n\nGenerate a time series with a given power spectral density (PSD) using the (Timmer and König, 1995) method.\n\nArguments\n\nrng::MersenneTwister: Random number generator.\nsim::Simulation: The simulation \nn::Int: Number of time series to generate. Default is 1.\ninput_mean::Real: The mean of the time series. Default is 0.\nσₓ::Array{Float64, 1}: The errorbars of the time series. Default is nothing.\nsplit_long::Bool: If true, the time series is split into shorter time series given by sim.S_low-1. Default is true.\nrandomise_values::Bool: If true, the values of the time series are randomised. Default is true.\nFvar::Real: The variance of the time series. Default is nothing.\nalt::Bool: If true, uses the alternative Timmer & Koenig method. Default is false. \npoisson::Bool: If true, Poisson noise is added to the time series. Default is false.\nexponentiate::Bool: If true, the time series is exponentiated. Default is false.\nerror_size::Real: The size of the error. Default is 0.05.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.draw_errorbars","page":"API Reference","title":"Tonari.draw_errorbars","text":"draw_errorbars(rng, x, Δt, poisson=false, error_size=0.05)\n\nDraw errorbars for the time series.\n\nArguments\n\nrng::MersenneTwister: Random number generator.\nx::Array{Float64, 1}: The values of the time series.\nΔt::Real: The sampling period.\npoisson::Bool: If true, Poisson noise is added to the time series. Default is false.\nerror_size::Real: The size of the error. Default is 0.05.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.findnearest-Tuple{Any, Any}","page":"API Reference","title":"Tonari.findnearest","text":"findnearest(a, b)\n\nFind the nearest value in b to each value in a. This assumes that a and b are sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.randomise_fluxes","page":"API Reference","title":"Tonari.randomise_fluxes","text":"randomise_fluxes(rng, xₛ, Δt, input_mean = 0.0; σ = nothing, Fvar = nothing, poisson = false, exponentiate = false, error_size = 0.05)\n\nRandomise the fluxes of the time series.\n\nArguments\n\nrng::MersenneTwister: Random number generator.\nxₛ::Array{Float64, 1}: The values of the time series.\nΔt::Real: The sampling period.\ninput_mean::Real: The mean of the time series. Default is 0.\nσ::Array{Float64, 1}: The errorbars of the time series. Default is nothing.\nFvar::Real: The variance of the time series. Default is nothing.\npoisson::Bool: If true, Poisson noise is added to the time series. Default is false.\nexponentiate::Bool: If true, the time series is exponentiated. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.sample_split_timeseries-NTuple{7, Any}","page":"API Reference","title":"Tonari.sample_split_timeseries","text":"sample_split_timeseries(x, t, t_desired, n_sim, n, n_slices, split_long)\n\nSplit the time series into shorter time series and sample at the desired time stamps.\n\nArguments\n\nx::Array{Float64, 1} or Vector{Matrix{Float64}}: The values of the time series. If there are multiple bands, the time series is a vector of matrices.\nt::Array{Float64, 1}: The time indexes of the time series.\nt_desired::Array{Float64, 1}: The desired time stamps.\nn_sim::Int: The number of simulations.\nn::Int: The number of time series to generate.\nn_slices::Int: The number of slices to break the time series into.\nsplit_long::Bool: If true, the time series is split into shorter time series. Default is true.\n\nReturns\n\nA tuple of two arrays: the first containing the time indexes of the shorter time series, and the second containing the values of the shorter time series.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.sample_timeseries-Tuple{Any, Any}","page":"API Reference","title":"Tonari.sample_timeseries","text":"sample_timeseries(t, y, M)\n\nExtract a random subset of points from the time series.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.split_longtimeseries-Tuple{Any, Any, Int64, Any}","page":"API Reference","title":"Tonari.split_longtimeseries","text":"split_longtimeseries(t, ts, n_slices, t_end)\n\nSplit a long time series into shorter time series. Break the time series into n_slices shorter time series. The short time series are of equal length.\n\nArguments\n\nt: The time indexes of the long time series.\nts: The values of the long time series.\nn_slices: The number of slices to break the time series into.\nt_end\n\nReturns\n\nA tuple of two lists: the first containing the time indexes of the shorter time series, and the second containing the values of the shorter time series.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.timmer_koenig-Tuple{Any, Random.AbstractRNG}","page":"API Reference","title":"Tonari.timmer_koenig","text":"timmer_koenig(psd, rng::random.AbstractRNG, alternative=false)\n\nGenerate a time series with a given power spectral density (PSD) using the (Timmer and König, 1995) method\n\nGiven N values of the power spectral density (PSD) 𝓟\nDraw 2N values from a standard normal distribution. \nThe amplitude of the randomised periodogram is given by A = N + i M\nThe randomised periodogram is given by 𝓟_rand = √(𝓟 / 2) * A\nThe first value of the randomised periodogram inserted and set to 0\nThe time series is obtained by taking the inverse Fourier transform of the randomised periodogram, with the function FFTW.irfft. We use the length of the time series as 2*(N+1)-1.\n\nThe alternative parametrisation is given by\n\nGiven N values of the power spectral density (PSD) 𝓟\nDraw N-1 values from a χ²(2)  distribution and 1 value from χ²₁(1), this is A the amplitude of the randomised periodogram\nDraw N values from a uniform distribution between 0 and 1, and set the last value to 0, this is θ the phase of the randomised periodogram\nThe randomised periodogram is given by 𝓟_rand = √(𝓟 / 2 * A) * exp(2πiθ)\nThe first value of the randomised periodogram inserted and set to 0\nThe time series is obtained by taking the inverse Fourier transform of the randomised periodogram, with the function FFTW.irfft. We use the length of the time series as 2*(N+1)-1.\n\nArguments\n\n𝓟::Array{Float64, 1}: PSD associated with the process\nrng::Random.AbstractRNG: Random number generator.\nα::Real: Multiplicative factor for the randomised periodogram. Default is 1.0. This can be a complex vector to add a phase to the time series.\n\nReturns\n\nx::Array{Float64, 1}: Time series with the given PSD.\n\n\n\n\n\n","category":"method"},{"location":"api/#Periodogram","page":"API Reference","title":"Periodogram","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Tonari]\nPages = [\"periodogram.jl\"]\nOrder = [:function]","category":"page"},{"location":"api/#Tonari.coherence","page":"API Reference","title":"Tonari.coherence","text":"coherence(f, C̄, P̄₁, P̄₂, n_segments, y₁_err = nothing, y₂_err = nothing)\n\nCompute the coherence between two time series defined in (Vaughan and Nowak, 1997) using the cross-periodogram C̄, the mean power spectrum of the first time series P̄₁, and the mean power spectrum of the second time series P̄₂. The coherence is defined as:\n\ngamma^2 (f) = fracoverlineC(f)^2overlineP_1(f) overlineP_2(f)\n\nwith the error in the coherence given by:\n\nsigma_gamma^2 = sqrt2 sqrtgamma^2 frac1 - gamma^2sqrtM\n\nwhere M is the number of segments over which the coherence is computed.\n\nThe phase lag is defined as:\n\nDelta phi (f) = arg overlineC(f)\n\nwith the error in the phase lag given by:\n\nsigma_Delta phi = frac1 - gamma^2sqrt2 gamma^2 M\n\nThe time lag is defined as:\n\nDelta tau (f) = fracDelta phi2 pi f\n\nwith the error in the time lag given by:\n\nsigma_Delta tau = fracsigma_Delta phi2 pi f\n\nIf the errors in the time series are provided, the corrected coherence is computed using the method described in (Vaughan and Nowak, 1997).\n\nArguments\n\nf::Array{Float64, 1}: Frequency array.\nC̄::Array{Complex{Float64}, 1}: Cross-periodogram.\nP̄₁::Array{Float64, 1}: Mean power spectrum of the first time series.\nP̄₂::Array{Float64, 1}: Mean power spectrum of the second time series.\nn_segments::Int: Number of segments over which the coherence is computed.\ny₁_err::Array{Float64, 1}: Error in the first time series.\ny₂_err::Array{Float64, 1}: Error in the second time series.\n\nif the errors in the time series are not provided, the function returns the coherence, phase lag, and time lag. Otherwise, it returns the corrected coherence, phase lag, and time lag.\n\nReturns\n\nf::Array{Float64, 1}: Frequency array.\nγ²::Array{Float64, 1}: Coherence.\nΔφ::Array{Float64, 1}: Phase lag.\nγ²_err::Array{Float64, 1}: Error in the coherence.\nΔφ_err::Array{Float64, 1}: Error in the phase lag.\nΔτ::Array{Float64, 1}: Time lag.\nΔτ_err::Array{Float64, 1}: Error in the time lag.\nP̄₁::Array{Float64, 1}: Mean power spectrum of the first time series.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.cross_periodogram","page":"API Reference","title":"Tonari.cross_periodogram","text":"cross_periodogram(t, y₁, y₂, y₁_err = nothing, y₂_err = nothing; compute_coherence = true, apply_end_matching = false, subtract_mean = true)\n\nCompute the cross-periodogram between two time series y₁ and y₂ with time stamps t using the fast Fourier transform (FFT).\n\nArguments\n\nt::Array{Float64, 1}: Time stamps.\ny₁::Array{Float64, 1}: First time series data. Or a matrix of multiple time series. \ny₂::Array{Float64, 1}: Second time series data. Or a matrix of multiple time series.\ny₁_err::Array{Float64, 1}: Error in the first time series. Or a matrix of errors for multiple time series.\ny₂_err::Array{Float64, 1}: Error in the second time series Or a matrix of errors for multiple time series.\ncompute_coherence::Bool: Compute the coherence between the two time series. Default is true.\napply_end_matching::Bool: Apply end-matching to the data. Default is false.\nsubtract_mean::Bool: Subtract the mean from the data. Default is true.\n\nIf compute_coherence  is true, the function returns the coherence between the two time series. Otherwise, it returns the cross-periodogram and the mean power spectra of the two time series. see coherence function for the optional returns.\n\nReturns\n\nf::Array{Float64, 1}: Frequency array.\nC̄::Array{Complex{Float64}, 1}: Mean cross-periodogram.\nP̄₁::Array{Float64, 1}: Mean power spectrum of the first time series.\nP̄₂::Array{Float64, 1}: Mean power spectrum of the second time series.\nC::Array{Complex{Float64}, 1}: Cross-periodogram.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.end_matching-Tuple{Any, Any}","page":"API Reference","title":"Tonari.end_matching","text":"end_matching(y,t)\n\nEnd-match the data y with a straight line and subtract it from the data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.periodogram","page":"API Reference","title":"Tonari.periodogram","text":"periodogram(y, t, normalisation = \"default\"; apply_end_matching = false, subtract_mean = true)\n\nCompute the periodogram of the data y with time stamps t using the fast Fourier transform (FFT).\n\nThe periodogram is computed as the squared magnitude of the Fourier transform of the data. In practrice we  use the real-valued fast Fourier transform (rfft) to compute the periodogram.\n\nArguments\n\ny::Array{Float64, 1}: Time series data.\nt::Array{Float64, 1}: Time stamps.\nnormalisation::Float64: Normalisation factor. Default is 2Δt / length(t).\napply_end_matching::Bool: Apply end-matching to the data. Default is false.\nsubtract_mean::Bool: Subtract the mean from the data. Default is true.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Tonari]\nPages = [\"timeseries.jl\"]\nOrder = [:function]","category":"page"},{"location":"api/#Tonari.fill_gaps","page":"API Reference","title":"Tonari.fill_gaps","text":"fill_gaps(rng::AbstractRNG, t::Vector{Float64}, x::Vector{Float64}, σₓ = nothing; randomise_values::Bool = true, poisson::Bool = true)\n\nFill gaps in a time series data with linear interpolation. If randomise_values = true, the interpolated values are drawn from a normal distribution with the mean and standard deviation of the data. If poisson = true, the interpolated values are drawn from a Poisson distribution with the mean of the data.\n\nArguments\n\nrng::AbstractRNG: random number generator\nt::Vector{Float64}: time array\nx::Vector{Float64}: data array\nσₓ::Vector{Float64}: standard deviation of the data array (optional)\nrandomise_values::Bool: whether to randomise the interpolated values\npoisson::Bool: whether to use a Poisson distribution for the interpolated values, this assumes that the data is in counts/dt\n\n\n\n\n\n","category":"function"},{"location":"periodogram/#Periodogram-computation","page":"Periodogram computation","title":"Periodogram computation","text":"","category":"section"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"The periodogram is an estimator for the power spectral density of a time series. It is defined as the squared magnitude of the discrete Fourier transform of the time series. We use the FFTW.jl package to compute the discrete Fourier transform efficiently:","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"X(f) = sum_n=1^N x_n e^-2pi i f n Delta t","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"where x_n is the time series , f is the frequency, and Delta t is the time interval between data points. The periodogram is then defined as ","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"I(f) = frac2T X(f)^2","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"where T=NDelta t is the total duration of the time series. The periodogram is an unbiased estimator of the power spectral density.","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"using Tonari\nusing Random\nusing Plots\nusing StatsBase \nrng = MersenneTwister(1234)","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"Let's start by simulating time series data with a single bending power law power spectral density model.","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"psd_model = SingleBendingPowerLaw(1.0, 1.13, 1.2e-1, 4.22)\nf = 10.0 .^ range(-3, stop=2, length=1000)\npsd = psd_model(f)\nT, Δt = 504.2, 0.12\nsimu = Simulation(psd_model, T, Δt)\nt, x, σ = sample(rng, simu, 10, error_size = 0.25)","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"We compute the average periodogram of the time series data using the function periodogram. It is common to subtract the mean of the time series before computing the periodogram. The function also allows for applying end-matching, which is useful for reducing spectral leakage when the first and last points of the time series are not close to each other in value. ","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"f,I = periodogram(t,x,apply_end_matching=false)","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"We can compare the periodogram to the model power spectral density. The noise level is given by 2Delta t times textmean(sigma^2), where sigma is the error on the time series data. See Appendix A of (Vaughan et al., 2003) for other normalisations and noise levels.","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"noise_level = 2Δt*mean(σ.^2)\n\nfx = 10.0 .^ range(-3, stop=0.5, length=1000)\nplot(f,I,yscale=:log10,xscale=:log10,xlabel=\"Frequency (Hz)\",ylabel=\"Power\",label=\"Periodogram\",framestyle=:box)\nplot!(fx,psd_model(fx),label=\"Model\",linewidth=2)\nhline!([noise_level],label=\"Noise level\",linewidth=2,linestyle=:dash)","category":"page"},{"location":"#Tonari","page":"Home","title":"Tonari","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tonari is a Julia package for time series analysis with an emphasis on astronomical applications.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\",\"simulations.md\",\"simulations_delays.md\",\"periodogram.md\", \"references.md\", \"api.md\"]\nDepth = 2","category":"page"},{"location":"simulations/#Simulating-univariate-time-series","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"","category":"section"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Let's simulate univariate time series data from a power spectrum model using the method of (Timmer and König, 1995).  First we need to load the Tonari package and the Random package for generating random numbers.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"using Tonari\nusing Random\nusing Plots\nusing StatsBase","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Let's define the power spectrum model, for instance we will use SingleBendingPowerLaw. ","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"psd_model = SingleBendingPowerLaw(1.0, 1.13, 1.2e-1, 4.22)\nf = 10.0 .^ range(-3, stop=2, length=1000)\npsd = psd_model(f)\nplot(f, psd, xscale=:log10, yscale=:log10, xlabel=\"Frequency\", ylabel=\"Power Spectrum Density\", label=\"Power Spectrum\", framestyle=:box)","category":"page"},{"location":"simulations/#Regularly-sampled-data","page":"Simulating univariate time series","title":"Regularly sampled data","text":"","category":"section"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Now we can simulate the time series data. We first define a Simulation struct with the power spectrum model,the total time T, the time step Δt, the mean count rate μ, and the variance σ². We can also add the S_low and S_high parameters to the simulation object. The S_low and S_high parameters are factors that extend the grid of frequencies. This is useful to avoid the cyclic effect of the discrete Fourier transform, the resulting time series is extracted from a longer time interval.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"\nT, Δt = 504.2, 0.132\nsimu = Simulation(psd_model, T, Δt, 10, 10)","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Now we can simulate the time series data by sampling the generative model.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"rng = MersenneTwister(42)\nN = 10\nt, x, σ = sample(rng, simu, N, error_size = 0.25)","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"note: Note\nThe split_long parameter is used to split the long time series into smaller segments to speed up the computation, by default this is enabled. This is useful when we want to simulate a large number of time series.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Finally, we can plot the simulated time series data.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"scatter(t, x[:, 1], label = nothing, yerr = σ[:, 1], xlabel = \"Time (days)\", ylabel = \"Value\", framestyle = :box, ms = 2)","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"We can check that the simulated time series data has the same power spectrum as the model.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"f,I = periodogram(t,x,apply_end_matching=false,subtract_mean=true)\nnoise_level = 2Δt*mean(σ.^2)\nfx = 10.0 .^ range(-3, stop=0.5, length=1000)\nplot(f,I,yscale=:log10,xscale=:log10,xlabel=\"Frequency (Hz)\",ylabel=\"Power\",label=\"Periodogram\",framestyle=:box)\nplot!(fx,psd_model(fx),label=\"Model\",linewidth=2)\nhline!([noise_level],label=\"Noise level\",linewidth=2,linestyle=:dash)","category":"page"},{"location":"simulations/#Irregularly-sampled-data","page":"Simulating univariate time series","title":"Irregularly sampled data","text":"","category":"section"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"We can also simulate irregularly sampled data. We first need to define the time stamps t. Let's draw the times from a uniform distribution.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"t = sort(sample(rng,collect(0:Δt:T),150,replace=false))","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"We now define the Simulation object  with the new time stamps.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"simu = Simulation(psd_model, t, 10, 10)","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"We can now sample the generative model.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"t_obs, x, σ = sample(rng, simu, error_size = 0.25)\nscatter(t_obs, x, label = nothing, yerr = σ, xlabel = \"Time (days)\", ylabel = \"Value\", framestyle = :box, ms = 2)","category":"page"},{"location":"simulations/#With-custom-errorbars","page":"Simulating univariate time series","title":"With custom errorbars","text":"","category":"section"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"It is possible to give the errorbars to randomise the data. The errorbars are given as a vector of the same length as the time stamps.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"simu = Simulation(psd_model, t)\nσs = 0.1 .+ 0.1 * rand(rng, length(t_obs))\n\nt_obs, x, σ = sample(rng, simu, σₓ=σs)\n@assert σ==σs\nscatter(t_obs, x, label = nothing, yerr = σs, xlabel = \"Time (days)\", ylabel = \"Value\", framestyle = :box, ms = 2)","category":"page"}]
}
