<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Tonari.jl</title><meta name="title" content="API Reference · Tonari.jl"/><meta property="og:title" content="API Reference · Tonari.jl"/><meta property="twitter:title" content="API Reference · Tonari.jl"/><meta name="description" content="Tonari.jl:"/><meta property="og:description" content="Tonari.jl:"/><meta property="twitter:description" content="Tonari.jl:"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Tonari.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Tonari.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Simulations</span><ul><li><a class="tocitem" href="../simulations/">Simulating univariate time series</a></li><li><a class="tocitem" href="../simulations_delays/">Simulating delayed time series</a></li></ul></li><li><span class="tocitem">Spectral analysis</span><ul><li><a class="tocitem" href="../periodogram/">Periodogram computation</a></li></ul></li><li><span class="tocitem">Time domain</span><ul><li><a class="tocitem" href="../correlations/">Lag and correlations between two time series</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Time-series"><span>Time series</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Simulations"><span>Simulations</span></a></li><li><a class="tocitem" href="#Periodogram"><span>Periodogram</span></a></li><li><a class="tocitem" href="#Correlations"><span>Correlations</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mlefkir/Tonari.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mlefkir/Tonari.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Time-series"><a class="docs-heading-anchor" href="#Time-series">Time series</a><a id="Time-series-1"></a><a class="docs-heading-anchor-permalink" href="#Time-series" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.IrregularTimeStamps" href="#Tonari.IrregularTimeStamps"><code>Tonari.IrregularTimeStamps</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IrregularTimeStamps</code></pre><p>A structure to store the time stamps of a time series. It contains the time stamps, the time step, the duration of the time series and a boolean to indicate if the time stamps are irregular. If the time stamps are irregular, the time step is the minimum time step between two time stamps.</p><p><strong>Fields</strong></p><ul><li><code>time::AbstractVector{T}</code>: the time stamps</li><li><code>unit::Unitful.Unit</code>: the unit of the time stamps (e.g. seconds, days, etc)</li><li><code>timezero::Td</code>: the time of the first time stamp</li><li><code>Δt::T</code>: the time step</li><li><code>duration::T</code>: the duration of the time series</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/timeseries.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.RegularTimeStamps" href="#Tonari.RegularTimeStamps"><code>Tonari.RegularTimeStamps</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RegularTimeStamps</code></pre><p>A structure to store the time stamps of a time series. It contains the time stamps, the time step, the duration of the time series and a boolean to indicate if the time stamps are irregular. If the time stamps are irregular, the time step is the minimum time step between two time stamps.</p><p><strong>Fields</strong></p><ul><li><code>Δt::T</code>: the time step</li><li><code>duration::T</code>: the duration of the time series</li><li><code>unit::Unitful.Unit</code>: the unit of the time stamps (e.g. seconds, days, etc)</li><li><code>timezero::Td</code>: the time of the first time stamp</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/timeseries.jl#L44-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.TimeSeries" href="#Tonari.TimeSeries"><code>Tonari.TimeSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimeSeries</code></pre><p>A structure to store a time series. It contains the time stamps, the data, and a dictionary to store metadata.</p><p><strong>Fields</strong></p><ul><li><code>time::TimeStamps{Tt,Tz}</code>: the time stamps</li><li><code>data::TimeSeriesData{Td, N}</code>: the data</li><li><code>metadata::Dict{Symbol, Any}</code>: a dictionary to store metadata</li></ul><p><strong>Entries in metadata</strong></p><ul><li><code>:name</code>: a string to store the name of the time series</li><li><code>:description</code>: a string to store a description of the time series</li><li><code>:unit</code>: a string to store the unit(s) of the data</li><li><code>:unit_time</code>: unit of the time stamps (default: seconds)</li><li><code>:timezero</code>: a string to store the time of the first time stamp</li><li><code>:fake</code>: a boolean to indicate if the time series is fake</li><li><code>:instrument</code>: a string to store the instrument used to measure the time series</li><li><code>:irregular</code>: a boolean to indicate if the time series has irregular time stamps</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/timeseries.jl#L112-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.TimeSeries-Union{Tuple{Td}, Tuple{T}, Tuple{AbstractVector{T}, Union{AbstractMatrix{Td}, Vector{Td}}}, Tuple{AbstractVector{T}, Union{AbstractMatrix{Td}, Vector{Td}}, Dict{Symbol, Any}}} where {T, Td}" href="#Tonari.TimeSeries-Union{Tuple{Td}, Tuple{T}, Tuple{AbstractVector{T}, Union{AbstractMatrix{Td}, Vector{Td}}}, Tuple{AbstractVector{T}, Union{AbstractMatrix{Td}, Vector{Td}}, Dict{Symbol, Any}}} where {T, Td}"><code>Tonari.TimeSeries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimeSeries(time::AbstractVector{T}, data::AbstractVector{Td}, metadata::Dict{Symbol,Any} = Dict{Symbol,Any}(), atol::T=0) where {T, Td}</code></pre><p>A constructor for the TimeSeries structure.</p><p>This function lets you create a TimeSeries structure using the times, data, and optional metadata.</p><p><strong>Arguments</strong></p><ul><li><code>time::AbstractVector{T}</code>: the time stamps of the time series (length N)</li><li><code>data::AbstractVector{Td}</code>: the data array (N x M) where N is the number of time stamps and M is the number of columns, M can be 1 for a single column, then data is a vector</li><li><code>metadata::Dict{Symbol,Any}</code>: a dictionary to store metadata</li><li><code>atol::T=0</code>: the absolute tolerance for the time stamps to check if they are regular</li></ul><p><strong>Metadata (optional but highly recommended)</strong></p><ul><li><code>:irregular</code>::Bool : a boolean to indicate if the time stamps are irregular</li><li><code>:unit_time</code>: the unit of the time stamps (default: seconds) using Unitful</li><li><code>:timezero</code>: the time of the first time stamp (default: time[1])</li><li><code>:columns</code>: the names of the columns (length M, default: y1, y2, ...), if M = 1, then the column is a Symbol</li><li><code>:unit</code>: the units of the columns (using Unitful) (length M, default: dimensionless), if M = 1, then the unit is a Symbol, but if all columns have the same unit, then the unit is a single unit</li><li><code>:name</code>: the name of the time series (optional)</li><li><code>:description</code>: a description of the time series (optional)</li><li><code>:fake</code>: a boolean to indicate if the time series is fake (optional)</li><li><code>:instrument</code>: the instrument used to measure the time series (optional)</li></ul><p><strong>Returns</strong></p><ul><li><code>TimeSeries</code>: a TimeSeries structure with the time stamps, data, and metadata</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/timeseries.jl#L139-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.TimeSeriesData" href="#Tonari.TimeSeriesData"><code>Tonari.TimeSeriesData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimeSeriesData</code></pre><p>A type for the data in the time series.</p><p><strong>Fields</strong></p><ul><li><code>Union{Vector{Symbol},Symbol}</code>: the names of the columns, e.g. flux, error. Can be a vector of symbols or a single symbol if there is only one column.</li><li><code>data::Union{AbstractArray{T,2},Vector{T}}</code>: the data array. Can be a matrix of data or a vector if there is only one column.</li><li><code>units::Union{Vector{Tu},Tu}</code>: the units of the data. Can be a vector of units or a single unit if there is only one column or the same unit is used for all columns.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/timeseries.jl#L74-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.fill_gaps" href="#Tonari.fill_gaps"><code>Tonari.fill_gaps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fill_gaps(rng::AbstractRNG, t::Vector{Float64}, x::Vector{Float64}, σₓ = nothing; randomise_values::Bool = true, poisson::Bool = true)</code></pre><p>Fill gaps in a time series data with linear interpolation. If <code>randomise_values = true</code>, the interpolated values are drawn from a normal distribution with the mean and standard deviation of the data. If <code>poisson = true</code>, the interpolated values are drawn from a Poisson distribution with the mean of the data.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG</code>: random number generator</li><li><code>t::Vector{Float64}</code>: time array</li><li><code>x::Vector{Float64}</code>: data array</li><li><code>σₓ</code>::Vector{Float64}: standard deviation of the data array (optional)</li><li><code>randomise_values::Bool</code>: whether to randomise the interpolated values (default: true)</li><li><code>poisson::Bool</code>: whether to use a Poisson distribution for the interpolated values, this assumes that the data is in counts/dt units (default: true)</li><li><code>Δt::Float64</code>: the time step of the time series (optional)</li></ul><p><strong>Returns</strong></p><ul><li><code>t_filled::Vector{Float64}</code>: the time array with the gaps filled</li><li><code>x_filled::Vector{Float64}</code>: the data array with the gaps filled</li><li><code>σ_filled::Vector{Float64}</code>: the standard deviation of the data array with the gaps filled (optional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/timeseries.jl#L238-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.time_series_sanity_checks-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, Any}} where T" href="#Tonari.time_series_sanity_checks-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, Any}} where T"><code>Tonari.time_series_sanity_checks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_series_sanity_checks(t₁::AbstractVector{T}, x₁::AbstractVector{T}, σ₁=nothing) where T</code></pre><p>Perform sanity checks on the time series. The function checks the following:</p><ul><li>The time and value vectors have the same length</li><li>The time and uncertainty vectors have the same length</li><li>The time series are sorted in ascending order</li><li>The time series do not contain infinities or NaNs</li></ul><p><strong>Arguments</strong></p><ul><li><code>t₁::AbstractVector{T}</code>: time points of the time series</li><li><code>x₁::AbstractVector{T}</code>: values of the time series</li><li><code>σ₁::AbstractVector{T}=nothing</code>: uncertainty of the time series</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/timeseries.jl#L310-L324">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><h3 id="Power-spectral-densities"><a class="docs-heading-anchor" href="#Power-spectral-densities">Power spectral densities</a><a id="Power-spectral-densities-1"></a><a class="docs-heading-anchor-permalink" href="#Power-spectral-densities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.DoubleBendingPowerLaw" href="#Tonari.DoubleBendingPowerLaw"><code>Tonari.DoubleBendingPowerLaw</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> DoubleBendingPowerLaw(A, α₁, f₁, α₂, f₂, α₃)</code></pre><p>Double bending power law model for the power spectral density</p><ul><li><code>A</code> : the amplitude</li><li><code>α₁</code>: the first power law index</li><li><code>f₁</code>: the first bend frequency</li><li><code>α₂</code>: the second power law index</li><li><code>f₂</code>: the second bend frequency</li><li><code>α₃</code>: the third power law index</li></ul><p class="math-container">\[\mathcal{P}(f) =  A\frac{(f/f₁)^{-α₁}}{1 + (f / f₁)^{α₂ - α₁}}\frac{1}{1 + (f / f₂)^{α₃ - α₂}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/psd.jl#L70-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.Lorentzian" href="#Tonari.Lorentzian"><code>Tonari.Lorentzian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Lorentzian(A, γ, f₀)</code></pre><p>Lorentzian model for the power spectral density</p><ul><li><code>A</code>: the amplitude</li><li><code>γ</code>: the width of the peak</li><li><code>f₀</code>: the central frequency</li></ul><p class="math-container">\[\mathcal{P}(f) =  \frac{A}{4\pi^2 (f - f₀)^2 + γ^2}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/psd.jl#L97-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.PowerLaw" href="#Tonari.PowerLaw"><code>Tonari.PowerLaw</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> PowerLaw(α)</code></pre><p>Power law model for the power spectral density</p><ul><li><code>α</code>: the power law index</li></ul><p class="math-container">\[\mathcal{P}(f) = A f^{-α}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/psd.jl#L27-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.QPO" href="#Tonari.QPO"><code>Tonari.QPO</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QPO(S₀, f₀,A Q)</code></pre><p>QPO model</p><ul><li><code>S₀</code>: the amplitude at the peak</li><li><code>f₀</code>: the central frequency</li><li><code>Q</code>: quality factor</li></ul><p class="math-container">\[\mathcal{P}(f) =  \frac{S_0 {f_0}^4 } {\left(f^ 2 -{f_0}^2\right)^ 2 + f^2 {f_0}^2 /  Q^2 }\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/psd.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.SingleBendingPowerLaw" href="#Tonari.SingleBendingPowerLaw"><code>Tonari.SingleBendingPowerLaw</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> SingleBendingPowerLaw(A, α₁, f₁, α₂)</code></pre><p>Single bending power law model for the power spectral density</p><ul><li><code>A</code>: the amplitude</li><li><code>α₁</code>: the first power law index</li><li><code>f₁</code>: the first bend frequency</li><li><code>α₂</code>: the second power law index</li></ul><p class="math-container">\[\mathcal{P}(f) =  A \frac{(f/f₁)^{-α₁}}{1 + (f / f₁)^{α₂ - α₁}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/psd.jl#L47-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.separate_psd-Tuple{PowerSpectralDensity}" href="#Tonari.separate_psd-Tuple{PowerSpectralDensity}"><code>Tonari.separate_psd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> separate_psd(psd::PowerSpectralDensity)</code></pre><p>Separate the PSD into its BendingPowerLaw components and other components if it is a sum of PSDs</p><p><strong>Arguments</strong></p><ul><li><code>psd::PowerSpectralDensity</code>: power spectral density or sum of PowerSpectralDensity objects</li></ul><p><strong>Return</strong></p><ul><li><code>psd_continuum::Union{SumOfPowerSpectralDensity,PowerSpectralDensity,nothing}</code>: continuum part of the psd</li><li><code>psd_line::Union{PowerSpectralDensity,nothing,Vector{PowerSpectralDensity}}</code>: non-continuum part of the psd</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/psd.jl#L165-L176">source</a></section></article><h2 id="Simulations"><a class="docs-heading-anchor" href="#Simulations">Simulations</a><a id="Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.Simulation" href="#Tonari.Simulation"><code>Tonari.Simulation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Simulation(model::Model, T::Real, Δt::Real, S_high::Real, S_low::Real, t::AbstractVector{Real})</code></pre><p>A struct that contains the information of a simulation of a stochastic process.</p><p><strong>Fields</strong></p><ul><li><code>model::Model</code>: The power spectral density of the process.</li><li><code>T::Real</code>: The duration of the simulated time series. Note that the time stamps are from 0 to <code>T</code>, so the duration is <code>T</code>.</li><li><code>Δt::Real</code>: The sampling period, or minimum time difference between samples.</li><li><code>S_high::Real</code>: The factor by which the maximum frequency is multiplied for the simulation.</li><li><code>S_low::Real</code>: The factor by which the minimum frequency is divided for the simulation.</li><li><code>t::AbstractVector{Real}</code>: The time vector, in this case, the time at which the process is sampled. It is assumed that the time vector is sorted.</li></ul><p><strong>Constructors</strong></p><ul><li><code>Simulation(model::Model, T::Real, Δt::Real, S_high::Real, S_low::Real, t::AbstractVector{Real})</code>: Constructs a simulation with regular sampling.</li><li><code>Simulation(model::Model, T::Real, Δt::Real)</code>: Constructs a simulation with regular sampling, and sets <code>S_high</code> and <code>S_low</code> to 10.0.</li><li><code>Simulation(model::Model, T::Real, Δt::Real, S_high::Real, S_low::Real)</code>: Constructs a simulation with the given parameters.</li><li><code>Simulation(model::Model, t::AbstractVector{Real}, S_high::Real, S_low::Real)</code>: Constructs a simulation with sampling pattern given by <code>t</code>.</li><li><code>Simulation(model::Model, t::AbstractVector{Real})</code>: Constructs a simulation with sampling pattern given by <code>t</code>, and sets <code>S_high</code> and <code>S_low</code> to 10.0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/simulate.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample(rng, sim, n=1, input_mean=0; σₓ = nothing, split_long=false, randomise_values=true, Fvar=nothing, alt=false, poisson=false, exponentiate=false, error_size=0.02)</code></pre><p>Generate a time series with a given power spectral density (PSD) using the (<a href="../references/#1995A&amp;A...300..707T">Timmer and König, 1995</a>) method.</p><p><strong>Arguments</strong></p><ul><li><code>rng::MersenneTwister</code>: Random number generator.</li><li><code>sim::Simulation</code>: The simulation</li><li><code>n::Int</code>: Number of time series to generate. Default is 1.</li><li><code>input_mean::Real</code>: The mean of the time series. Default is 0.</li><li><code>σₓ::Array{Float64, 1}</code>: The errorbars of the time series. Default is nothing.</li><li><code>split_long::Bool</code>: If true, the time series is split into shorter time series given by <code>sim.S_low</code>-1. Default is true.</li><li><code>randomise_values::Bool</code>: If true, the values of the time series are randomised. Default is true.</li><li><code>Fvar::Real</code>: The variance of the time series. Default is nothing.</li><li><code>alt::Bool</code>: If true, uses the alternative Timmer &amp; Koenig method. Default is false.</li><li><code>poisson::Bool</code>: If true, Poisson noise is added to the time series. Default is false.</li><li><code>exponentiate::Bool</code>: If true, the time series is exponentiated. Default is false.</li><li><code>error_size::Real</code>: The size of the error. Default is 0.05.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/simulate.jl#L361-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.draw_errorbars" href="#Tonari.draw_errorbars"><code>Tonari.draw_errorbars</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">draw_errorbars(rng, x, Δt, poisson=false, error_size=0.05)</code></pre><p>Draw errorbars for the time series.</p><p><strong>Arguments</strong></p><ul><li><code>rng::MersenneTwister</code>: Random number generator.</li><li><code>x::Array{Float64, 1}</code>: The values of the time series.</li><li><code>Δt::Real</code>: The sampling period.</li><li><code>poisson::Bool</code>: If true, Poisson noise is added to the time series. Default is false.</li><li><code>error_size::Real</code>: The size of the error. Default is 0.05.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/simulate.jl#L283-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.findnearest-Tuple{Any, Any}" href="#Tonari.findnearest-Tuple{Any, Any}"><code>Tonari.findnearest</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findnearest(a, b)</code></pre><p>Find the nearest value in <code>b</code> to each value in <code>a</code>. This assumes that a and b are sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/simulate.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.randomise_fluxes" href="#Tonari.randomise_fluxes"><code>Tonari.randomise_fluxes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">randomise_fluxes(rng, xₛ, Δt, input_mean = 0.0; σ = nothing, Fvar = nothing, poisson = false, exponentiate = false, error_size = 0.05)</code></pre><p>Randomise the fluxes of the time series.</p><p><strong>Arguments</strong></p><ul><li><code>rng::MersenneTwister</code>: Random number generator.</li><li><code>xₛ::Array{Float64, 1}</code>: The values of the time series.</li><li><code>Δt::Real</code>: The sampling period.</li><li><code>input_mean::Real</code>: The mean of the time series. Default is 0.</li><li><code>σ::Array{Float64, 1}</code>: The errorbars of the time series. Default is nothing.</li><li><code>Fvar::Real</code>: The variance of the time series. Default is nothing.</li><li><code>poisson::Bool</code>: If true, Poisson noise is added to the time series. Default is false.</li><li><code>exponentiate::Bool</code>: If true, the time series is exponentiated. Default is false.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/simulate.jl#L305-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.sample_split_timeseries-NTuple{7, Any}" href="#Tonari.sample_split_timeseries-NTuple{7, Any}"><code>Tonari.sample_split_timeseries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_split_timeseries(x, t, t_desired, n_sim, n, n_slices, split_long)</code></pre><p>Split the time series into shorter time series and sample at the desired time stamps.</p><p><strong>Arguments</strong></p><ul><li><code>x::Array{Float64, 1}</code> or <code>Vector{Matrix{Float64}}</code>: The values of the time series. If there are multiple bands, the time series is a vector of matrices.</li><li><code>t::Array{Float64, 1}</code>: The time indexes of the time series.</li><li><code>t_desired::Array{Float64, 1}</code>: The desired time stamps.</li><li><code>n_sim::Int</code>: The number of simulations.</li><li><code>n::Int</code>: The number of time series to generate.</li><li><code>n_slices::Int</code>: The number of slices to break the time series into.</li><li><code>split_long::Bool</code>: If true, the time series is split into shorter time series. Default is true.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple of two arrays: the first containing the time indexes of the shorter time series, and the second containing the values of the shorter time series.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/simulate.jl#L179-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.sample_timeseries-Tuple{Any, Any}" href="#Tonari.sample_timeseries-Tuple{Any, Any}"><code>Tonari.sample_timeseries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_timeseries(t, y, M)</code></pre><p>Extract a random subset of points from the time series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/simulate.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.split_longtimeseries-Tuple{Any, Any, Int64, Any}" href="#Tonari.split_longtimeseries-Tuple{Any, Any, Int64, Any}"><code>Tonari.split_longtimeseries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_longtimeseries(t, ts, n_slices, t_end)</code></pre><p>Split a long time series into shorter time series. Break the time series into <code>n_slices</code> shorter time series. The short time series are of equal length.</p><p><strong>Arguments</strong></p><ul><li><code>t</code>: The time indexes of the long time series.</li><li><code>ts</code>: The values of the long time series.</li><li><code>n_slices</code>: The number of slices to break the time series into.</li><li><code>t_end</code></li></ul><p><strong>Returns</strong></p><ul><li>A tuple of two lists: the first containing the time indexes of the shorter time series, and the second containing the values of the shorter time series.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/simulate.jl#L115-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.timmer_koenig-Tuple{Any, Random.AbstractRNG}" href="#Tonari.timmer_koenig-Tuple{Any, Random.AbstractRNG}"><code>Tonari.timmer_koenig</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timmer_koenig(psd, rng::random.AbstractRNG, alternative=false)</code></pre><p>Generate a time series with a given power spectral density (PSD) using the (<a href="../references/#1995A&amp;A...300..707T">Timmer and König, 1995</a>) method</p><ol><li>Given N values of the power spectral density (PSD) 𝓟</li><li>Draw 2N values from a standard normal distribution.</li><li>The amplitude of the randomised periodogram is given by A = N + i M</li><li>The randomised periodogram is given by 𝓟_rand = √(𝓟 / 2) * A</li><li>The first value of the randomised periodogram inserted and set to 0</li><li>The time series is obtained by taking the inverse Fourier transform of the randomised periodogram, with the function FFTW.irfft. We use the length of the time series as 2*(N+1)-1.</li></ol><p>The alternative parametrisation is given by</p><ol><li>Given N values of the power spectral density (PSD) 𝓟</li><li>Draw N-1 values from a χ²(2)  distribution and 1 value from χ²₁(1), this is A the amplitude of the randomised periodogram</li><li>Draw N values from a uniform distribution between 0 and 1, and set the last value to 0, this is θ the phase of the randomised periodogram</li><li>The randomised periodogram is given by 𝓟_rand = √(𝓟 / 2 * A) * exp(2πiθ)</li><li>The first value of the randomised periodogram inserted and set to 0</li><li>The time series is obtained by taking the inverse Fourier transform of the randomised periodogram, with the function FFTW.irfft. We use the length of the time series as 2*(N+1)-1.</li></ol><p><strong>Arguments</strong></p><ul><li><code>𝓟::Array{Float64, 1}</code>: PSD associated with the process</li><li><code>rng::Random.AbstractRNG</code>: Random number generator.</li><li><code>α::Real</code>: Multiplicative factor for the randomised periodogram. Default is 1.0. This can be a complex vector to add a phase to the time series.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Array{Float64, 1}</code>: Time series with the given PSD.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/simulate.jl#L52-L81">source</a></section></article><h2 id="Periodogram"><a class="docs-heading-anchor" href="#Periodogram">Periodogram</a><a id="Periodogram-1"></a><a class="docs-heading-anchor-permalink" href="#Periodogram" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.coherence" href="#Tonari.coherence"><code>Tonari.coherence</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coherence(f, C̄, P̄₁, P̄₂, n_segments, y₁_err = nothing, y₂_err = nothing)</code></pre><p>Compute the coherence between two time series defined in (<a href="../references/#1997ApJ...474L..43V">Vaughan and Nowak, 1997</a>) using the cross-periodogram <code>C̄</code>, the mean power spectrum of the first time series <code>P̄₁</code>, and the mean power spectrum of the second time series <code>P̄₂</code>. The coherence is defined as:</p><p class="math-container">\[\gamma^2 (f) = \frac{|\overline{C}(f)|^2}{\overline{P}_1(f) \overline{P}_2(f)}\]</p><p>with the error in the coherence given by:</p><p class="math-container">\[\sigma_{\gamma^2} = \sqrt{2} \sqrt{\gamma^2} \frac{1 - \gamma^2}{\sqrt{M}}\]</p><p>where <code>M</code> is the number of segments over which the coherence is computed.</p><p>The phase lag is defined as:</p><p class="math-container">\[\Delta \phi (f) = \arg \overline{C}(f)\]</p><p>with the error in the phase lag given by:</p><p class="math-container">\[\sigma_{\Delta \phi} = \frac{1 - \gamma^2}{\sqrt{2 \gamma^2 M}}\]</p><p>The time lag is defined as:</p><p class="math-container">\[\Delta \tau (f) = \frac{\Delta \phi}{2 \pi f}\]</p><p>with the error in the time lag given by:</p><p class="math-container">\[\sigma_{\Delta \tau} = \frac{\sigma_{\Delta \phi}}{2 \pi f}\]</p><p>If the errors in the time series are provided, the corrected coherence is computed using the method described in (<a href="../references/#1997ApJ...474L..43V">Vaughan and Nowak, 1997</a>).</p><p><strong>Arguments</strong></p><ul><li><code>f::Array{Float64, 1}</code>: Frequency array.</li><li><code>C̄::Array{Complex{Float64}, 1}</code>: Cross-periodogram.</li><li><code>P̄₁::Array{Float64, 1}</code>: Mean power spectrum of the first time series.</li><li><code>P̄₂::Array{Float64, 1}</code>: Mean power spectrum of the second time series.</li><li><code>n_segments::Int</code>: Number of segments over which the coherence is computed.</li><li><code>y₁_err::Array{Float64, 1}</code>: Error in the first time series.</li><li><code>y₂_err::Array{Float64, 1}</code>: Error in the second time series.</li></ul><p>if the errors in the time series are not provided, the function returns the coherence, phase lag, and time lag. Otherwise, it returns the corrected coherence, phase lag, and time lag.</p><p><strong>Returns</strong></p><ul><li><code>f::Array{Float64, 1}</code>: Frequency array.</li><li><code>γ²::Array{Float64, 1}</code>: Coherence.</li><li><code>Δφ::Array{Float64, 1}</code>: Phase lag.</li><li><code>γ²_err::Array{Float64, 1}</code>: Error in the coherence.</li><li><code>Δφ_err::Array{Float64, 1}</code>: Error in the phase lag.</li><li><code>Δτ::Array{Float64, 1}</code>: Time lag.</li><li><code>Δτ_err::Array{Float64, 1}</code>: Error in the time lag.</li><li><code>P̄₁::Array{Float64, 1}</code>: Mean power spectrum of the first time series.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/periodogram.jl#L207-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.cross_periodogram" href="#Tonari.cross_periodogram"><code>Tonari.cross_periodogram</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cross_periodogram(t, y₁, y₂, y₁_err = nothing, y₂_err = nothing; compute_coherence = true, apply_end_matching = false, subtract_mean = true)</code></pre><p>Compute the cross-periodogram between two time series y₁ and y₂ with time stamps t using the fast Fourier transform (FFT).</p><p><strong>Arguments</strong></p><ul><li><code>t::Array{Float64, 1}</code>: Time stamps.</li><li><code>y₁::Array{Float64, 1}</code>: First time series data. Or a matrix of multiple time series.</li><li><code>y₂::Array{Float64, 1}</code>: Second time series data. Or a matrix of multiple time series.</li><li><code>y₁_err::Array{Float64, 1}</code>: Error in the first time series. Or a matrix of errors for multiple time series.</li><li><code>y₂_err::Array{Float64, 1}</code>: Error in the second time series Or a matrix of errors for multiple time series.</li><li><code>compute_coherence::Bool</code>: Compute the coherence between the two time series. Default is true.</li><li><code>apply_end_matching::Bool</code>: Apply end-matching to the data. Default is false.</li><li><code>subtract_mean::Bool</code>: Subtract the mean from the data. Default is true.</li></ul><p>If compute_coherence  is true, the function returns the coherence between the two time series. Otherwise, it returns the cross-periodogram and the mean power spectra of the two time series. see <code>coherence</code> function for the optional returns.</p><p><strong>Returns</strong></p><ul><li><code>f::Array{Float64, 1}</code>: Frequency array.</li><li><code>C̄::Array{Complex{Float64}, 1}</code>: Mean cross-periodogram.</li><li><code>P̄₁::Array{Float64, 1}</code>: Mean power spectrum of the first time series.</li><li><code>P̄₂::Array{Float64, 1}</code>: Mean power spectrum of the second time series.</li><li><code>C::Array{Complex{Float64}, 1}</code>: Cross-periodogram.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/periodogram.jl#L92-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.end_matching-Tuple{Any, Any}" href="#Tonari.end_matching-Tuple{Any, Any}"><code>Tonari.end_matching</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">end_matching(y,t)</code></pre><p>End-match the data y with a straight line and subtract it from the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/periodogram.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.periodogram" href="#Tonari.periodogram"><code>Tonari.periodogram</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">periodogram(t,y, normalisation = &quot;default&quot;; apply_end_matching = false, subtract_mean = true)</code></pre><p>Compute the periodogram of the data y with time stamps t using the fast Fourier transform (FFT).</p><p>The periodogram is computed as the squared magnitude of the Fourier transform of the data. In practrice we use the real-valued fast Fourier transform (rfft) to compute the periodogram.</p><p><strong>Arguments</strong></p><ul><li><code>t::Array{Float64, 1}</code>: Time stamps.</li><li><code>y::Array{Float64, 1}</code>: Time series data.</li><li><code>normalisation::Float64</code>: Normalisation factor. Default is 2Δt / length(t).</li><li><code>apply_end_matching::Bool</code>: Apply end-matching to the data. Default is false.</li><li><code>subtract_mean::Bool</code>: Subtract the mean from the data. Default is true.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/periodogram.jl#L13-L27">source</a></section></article><h2 id="Correlations"><a class="docs-heading-anchor" href="#Correlations">Correlations</a><a id="Correlations-1"></a><a class="docs-heading-anchor-permalink" href="#Correlations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.cross_correlate-Union{Tuple{T}, Tuple{Random.AbstractRNG, Vararg{AbstractVector{T}, 4}}} where T" href="#Tonari.cross_correlate-Union{Tuple{T}, Tuple{Random.AbstractRNG, Vararg{AbstractVector{T}, 4}}} where T"><code>Tonari.cross_correlate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cross_correlate(t₁::AbstractVector{T}, x₁::AbstractVector{T}, t₂::AbstractVector{T}, x₂::AbstractVector{T}; σ₁=nothing, σ₂=nothing, τ_list=nothing, Δτ=nothing, max_lag=nothing, local_estimate=false, both_ways=true, method=&quot;iccf&quot;, compute_errors=false, peak_frac=0.8, bootstrap=false, n_simulations=1_000,
skip_sanity_checks = false) where T</code></pre><p>Compute the cross-correlation function between two time series.</p><p>The function computes the cross-correlation function between two time series by linearly interpolating the second time series using the interpolated cross-correlation function (ICCF) method. Most of this code is based on the R package <code>sour</code> by Simon Vaughan, University of Leicester https://github.com/SimonVaughanDataAndCode/sour.</p><p><strong>Arguments</strong></p><ul><li><code>t₁::AbstractVector{T}</code>: time stamps of the first time series</li><li><code>x₁::AbstractVector{T}</code>: values of the first time series</li><li><code>t₂::AbstractVector{T}</code>: time stamps of the second time series</li><li><code>x₂::AbstractVector{T}</code>: values of the second time series</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>σ₁::AbstractVector{T} = nothing</code>: uncertainty of the first time series</li><li><code>σ₂::AbstractVector{T} = nothing</code>: uncertainty of the second time series</li><li><code>τ_list::AbstractVector{T} = nothing</code>: list of time lags, if not provided, it will be computed based on the time range of the time series</li><li><code>Δτ::T = nothing</code>: time step between the time lags</li><li><code>max_lag::T = nothing</code>: maximum time lag</li><li><code>local_estimate::Bool = false</code>: flag to estimate the local mean and standard deviation of the time series</li><li><code>both_ways::Bool = true</code>: Compute the cross-correlation function in both ways, i.e., from the first to the second time series and from the second to the first time series</li><li><code>method::String = &quot;iccf&quot;</code>: method to compute the cross-correlation function</li><li><code>compute_errors::Bool = false</code>: flag to compute the errors of the cross-correlation function</li><li><code>peak_frac::T = 0.8</code>: fraction of the peak to integrate to get the lag</li><li><code>bootstrap::Bool = false</code>: flag to compute the errors using bootstrapping</li><li><code>n_simulations::Int = 1_000</code>: number of simulations to compute the errors</li><li><code>skip_sanity_checks::Bool = false</code>: flag to skip the sanity checks</li></ul><p><strong>Returns</strong></p><ul><li><code>τ_list::AbstractVector{T}</code>: list of time lags</li><li><code>r::AbstractVector{T}</code>: cross-correlation function</li><li><code>q::AbstractVector{T}</code>: Distribution of centroid lags if <code>compute_errors</code> is <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/iccf.jl#L49-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.get_lag_list-NTuple{5, Any}" href="#Tonari.get_lag_list-NTuple{5, Any}"><code>Tonari.get_lag_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_lag_list(Δτ, max_lag,t₁,t₂,τ_list)</code></pre><p>Get the list of time lags to compute the cross-correlation function.</p><p><strong>Arguments</strong></p><ul><li><code>Δτ::T</code>: time step between the time lags</li><li><code>max_lag::T</code>: maximum time lag</li><li><code>t₁::AbstractVector{T}</code>: time stamps of the first time series</li><li><code>t₂::AbstractVector{T}</code>: time stamps of the second time series</li><li><code>τ_list::AbstractVector{T}</code>: list of time lags</li></ul><p><strong>Returns</strong></p><ul><li><code>τ_list::AbstractVector{T}</code>: list of time lags</li><li><code>Δτ::T</code>: time step between the time lags</li><li><code>max_lag::T</code>: maximum time lag</li><li><code>n_lags::Int64</code>: number of time lags</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/iccf.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.iccf-Union{Tuple{T}, NTuple{5, AbstractVector{T}}} where T" href="#Tonari.iccf-Union{Tuple{T}, NTuple{5, AbstractVector{T}}} where T"><code>Tonari.iccf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iccf(t₁::AbstractVector{T}, x₁::AbstractVector{T}, t₂::AbstractVector{T}, x₂::AbstractVector{T}, τ_list::AbstractVector{T} ; local_estimate=false) where T</code></pre><p>Compute the interpolated cross-correlation function (ICCF) between two time series.</p><p>The function computes the cross-correlation function between two time series by linearly interpolating the second time series on the time points of the first time series. The ICCF is presented in Edelson et al. 2017  https://ui.adsabs.harvard.edu/abs/2017ApJ...840...41E/abstract and Peterson et al. 2004 https://ui.adsabs.harvard.edu/abs/2004ApJ...613..682P/abstract. The current implementation is based on the R package <code>sour</code> by Simon Vaughan, University of Leicester https://github.com/SimonVaughanDataAndCode/sour.</p><p>https://ui.adsabs.harvard.edu/abs/1986ApJ...305..175G/abstract</p><p><strong>Arguments</strong></p><ul><li><code>t₁::AbstractVector{T}</code>: time points of the first time series</li><li><code>x₁::AbstractVector{T}</code>: values of the first time series</li><li><code>t₂::AbstractVector{T}</code>: time points of the second time series</li><li><code>x₂::AbstractVector{T}</code>: values of the second time series</li><li><code>τ_list::AbstractVector{T}</code>: list of time lags</li><li><code>local_estimate::Bool=false</code>: flag to estimate the local mean and standard deviation of the time series</li></ul><p><strong>Returns</strong></p><ul><li><code>CCF::Vector{T}</code>: cross-correlation function</li><li><code>nx::Vector{Int64}</code>: number of points in each time lag bin</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Random
Random.seed!(123)
t₁ = 0:0.1:10
x₁ = randn(length(t₁))
t₂ = 0:0.1:10
x₂ = randn(length(t₂))
τ_list = -10:0.1:10
CCF,nx = iccf(t₁, x₁, t₂, x₂, τ_list)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/iccf.jl#L190-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.iccf_errors-Union{Tuple{T}, Tuple{Random.AbstractRNG, Vararg{AbstractVector{T}, 4}}} where T" href="#Tonari.iccf_errors-Union{Tuple{T}, Tuple{Random.AbstractRNG, Vararg{AbstractVector{T}, 4}}} where T"><code>Tonari.iccf_errors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iccf_errors(rng::AbstractRNG, t₁::AbstractVector{T}, x₁::AbstractVector{T}, t₂::AbstractVector{T}, x₂::AbstractVector{T}, σ₁::AbstractVector{T} = nothing, σ₂::AbstractVector{T} = nothing,peak_frac = 0.8,local_estimate = false,τ_list = nothing,bootstrap = false,n_simulations = 1_000) where {T}</code></pre><p>Compute the errors of the interpolated cross-correlation function (ICCF) between two time series.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG</code>: Random number generator</li><li><code>t₁::AbstractVector{T}</code>: time points of the first time series</li><li><code>x₁::AbstractVector{T}</code>: values of the first time series</li><li><code>t₂::AbstractVector{T}</code>: time points of the second time series</li><li><code>x₂::AbstractVector{T}</code>: values of the second time series</li><li><code>σ₁::AbstractVector{T} = nothing</code>: uncertainty of the first time series</li><li><code>σ₂::AbstractVector{T} = nothing</code>: uncertainty of the second time series</li><li><code>peak_frac::T = 0.8</code>: fraction of the peak to integrate to get the lag</li><li><code>local_estimate::Bool = false</code>: flag to estimate the local mean and standard deviation of the time series</li><li><code>τ_list::AbstractVector{T} = nothing</code>: list of time lags</li><li><code>bootstrap::Bool = false</code>: flag to compute the errors using bootstrapping</li><li><code>n_simulations::Int = 1_000</code>: number of simulations to compute the errors</li></ul><p><strong>Returns</strong></p><ul><li><code>q::Vector{T}</code>: array of lags</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/iccf.jl#L294-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.randomise_lc_flux-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, AbstractVector{T}}} where T" href="#Tonari.randomise_lc_flux-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, AbstractVector{T}}} where T"><code>Tonari.randomise_lc_flux</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">randomise_lc_flux(rng::AbstractRNG, t::Vector{Float64}, x::Vector{Float64}; σ::Vector{Float64} = nothing, bootstrap::Bool = false)</code></pre><p>Randomise the light curve by sampling with replacement. If <code>bootstrap</code> is <code>true</code>, the errors are not added to the light curve.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG</code>: Random number generator</li><li><code>t::Vector{Float64}</code>: Time array</li><li><code>x::Vector{Float64}</code>: Flux array</li><li><code>σ::Vector{Float64}</code>: Error array</li><li><code>bootstrap::Bool</code>: If <code>true</code>, the errors are not added to the light curve</li></ul><p><strong>Returns</strong></p><ul><li><code>t_samp::Vector{Float64}</code>: Sampled time array</li><li><code>x_samp::Vector{Float64}</code>: Sampled flux array</li><li><code>σ_samp::Vector{Float64}</code>: Sampled error array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/9b9c457f8e972c29c730405c7ababd1e2cb1e55a/src/iccf.jl#L356-L372">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../references/">« References</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Tuesday 27 May 2025 13:58">Tuesday 27 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
