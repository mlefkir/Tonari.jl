var documenterSearchIndex = {"docs":
[{"location":"simulations_delays/#Simulating-delayed-time-series","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"","category":"section"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"Let's simulate two time series with a delay","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"using Tonari\nusing Random\nusing Plots\nusing StatsBase\nrng = MersenneTwister(42)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"Let's define the individual power spectral densities and the phase delay. We will use two bending power laws and a constant time delay.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"p1 = SingleBendingPowerLaw(1.0, 0.63, 10e-2, 3.22)\np2 = SingleBendingPowerLaw(1.0, 0.78, 13e-2, 3.81)\nΔϕ = ConstantTimeLag(12.35)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"The cross-spectral density is defined by the two power spectral densities and the phase delay.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"cs = CrossSpectralDensity(p1, p2, Δϕ)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"We can now simulate the time series using the Simulation type.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"T, Δt = 504.2, 0.133\nsimu = Simulation(cs, T, Δt)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"and sample 50 time series.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"t, y, yerr = sample(rng,simu,50,error_size=0.15)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"scatter(t,y[1][:,1],yerr=yerr[1][:,1],label=\"1\", framestyle=:box)\nscatter!(t,y[2][:,1],yerr=yerr[2][:,1],label=\"2\", framestyle=:box, xlabel=\"Time (days)\", ylabel=\"Value\")","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"The cross periodogram can be computed using the cross_periodogram function. γ² is the coherence, Δφ the phase difference and Δτ the time delay.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"f, γ², γ²_corrected, Δφ, γ²_err, γ²_corrected_err, Δφ_err, Δτ, Δτ_err, P̄₁, P̄₂, N₁, N₂, n = cross_periodogram(t, y[1], y[2], yerr[1],yerr[2])","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"The individual periodograms can be plotted:","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"plot(f,P̄₁,label=\"P₁\")\nplot!(f,P̄₂,xscale=:log10,yscale=:log10,label=\"P₂\",xlabel=\"Frequency (d^-1)\",ylabel=\"Power\")\nhline!([N₁,N₂],linestyle=:dash,label=\"noise level\", framestyle=:box)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"The coherence and the phase difference can be plotted as a function of the frequency:","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"l = @layout [a; b]\np1 = scatter(f, γ²_corrected, yerr=γ²_corrected_err, label=\"γ² corrected\",marker=:square,ms=4,xscale=:log10,size=(800,400))\np1 = scatter!(f, γ², yerr=γ²_err, label=\"γ²\", xscale=:log10,ylims=(0,1.1),ms=4,ylabel=\"Coherence\",link=:x, framestyle=:box)\np2 = scatter(f, Δτ, yerr=Δτ_err, xscale=:log10, ylabel=\"Time delay (d)\",xlabel=\"Frequency (d^-1)\",link=:x, framestyle=:box,label=nothing)\np2 = hline!([Δϕ.Δτ ],color=:black,label=\"True delay\")\nplot(p1, p2, layout=l,size=(800,600))","category":"page"},{"location":"simulations_delays/#With-a-constant-phaselag","page":"Simulating delayed time series","title":"With a constant phaselag","text":"","category":"section"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"p1 = SingleBendingPowerLaw(1.0, 0.63, 10e-2, 3.22)\np2 = SingleBendingPowerLaw(1.0, 0.78, 13e-2, 3.81)\nΔϕ = ConstantPhaseLag(56.2,5*1/T)\n\ncs = CrossSpectralDensity(p1, p2, Δϕ)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"T, Δt = 504.2, 0.133\nsimu = Simulation(cs, T, Δt)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"t, y, yerr = sample(rng,simu,50,error_size=0.15)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"scatter(t,y[1][:,1],yerr=yerr[1][:,1],label=\"1\", framestyle=:box)\nscatter!(t,y[2][:,1],yerr=yerr[2][:,1],label=\"2\", framestyle=:box, xlabel=\"Time (days)\", ylabel=\"Value\")","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"f, γ², γ²_corrected, Δφ, γ²_err, γ²_corrected_err, Δφ_err, Δτ, Δτ_err, P̄₁, P̄₂, N₁, N₂, n = cross_periodogram(t, y[1], y[2], yerr[1],yerr[2])","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"plot(f,P̄₁,label=\"P₁\")\nplot!(f,P̄₂,xscale=:log10,yscale=:log10,label=\"P₂\",xlabel=\"Frequency (d^-1)\",ylabel=\"Power\")\nhline!([N₁,N₂],linestyle=:dash,label=\"noise level\", framestyle=:box)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"l = @layout [a; b ; c]\np1 = scatter(f, γ²_corrected, yerr=γ²_corrected_err, label=\"γ² corrected\",marker=:square,ms=4,xscale=:log10,size=(800,400))\np1 = scatter!(f, γ², yerr=γ²_err, label=\"γ²\", xscale=:log10,ylims=(0,1.1),ms=4,ylabel=\"Coherence\",link=:x, framestyle=:box)\n\np2 = scatter(f, Δφ, yerr=Δφ_err, xscale=:log10, ylabel=\"Time delay (d)\",xlabel=\"Frequency (d^-1)\",link=:x, framestyle=:box,label=nothing)\np2 = plot!(f,Δϕ(f) .* 2 .*pi .* f )\nprintln(Δϕ(f[1]) .* 2 .*pi .* f[1] )\n\np3 = scatter(f, Δτ, yerr=Δτ_err, xscale=:log10, ylabel=\"Time delay (d)\",xlabel=\"Frequency (d^-1)\",link=:x, framestyle=:box,label=nothing)\np3 = plot!(f,-Δϕ(f) )\n\nplot(p1, p2,p3, layout=l,size=(800,900))","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Edelson, R.; Gelbord, J.; Cackett, E.; Connolly, S.; Done, C.; Fausnaugh, M.; Gardner, E.; Gehrels, N.; Goad, M.; Horne, K.; McHardy, I.; Peterson, B.; Vaughan, S.; Vestergaard, M.; Breeveld, A.; Barth, A.; Bentz, M.; Bottorff, M.; Brandt, W.; Crawford, S.; Dalla Bontà, E.; Emmanoulopoulos, D.; Evans, P.; Figuera Jaimes, R.; Filippenko, A.; Ferland, G.; Grupe, D.; Joner, M.; Kennea, J.; Korista, K.; Krimm, H.; Kriss, G.; Leonard, D.; Mathur, S.; Netzer, H.; Nousek, J.; Page, K.; Romero-Colmenero, E.; Siegel, M.; Starkey, D.; Treu, T.; Vogler, H.; Winkler, H. and Zheng, W. (2017). Swift Monitoring of NGC 4151: Evidence for a Second X-Ray/UV Reprocessing, apj 840, 41, arXiv:1703.06901 [astro-ph.HE].\n\n\n\nEdelson, R. and Krolik, J. (1988). The Discrete Correlation Function: A New Method for Analyzing Unevenly Sampled Variability Data, apj 333, 646.\n\n\n\nGaskell, C. and Sparke, L. (1986). Line Variations in Quasars and Seyfert Galaxies, apj 305, 175.\n\n\n\nPeterson, B. M.; Wanders, I.; Horne, K.; Collier, S.; Alexander, T.; Kaspi, S. and Maoz, D. (1998). On Uncertainties in Cross-Correlation Lags and the Reality of Wavelength-dependent Continuum Lags in Active Galactic Nuclei, pasp 110, 660–670, arXiv:astro-ph/9802103 [astro-ph].\n\n\n\nTimmer, J. and König, M. (1995). On generating power law noise. aap 300, 707.\n\n\n\nVaughan, B. A. and Nowak, M. A. (1997). X-Ray Variability Coherence: How to Compute It, What It Means, and How It Constrains Models of GX 339-4 and Cygnus X-1, apjl 474, L43-L46, arXiv:astro-ph/9610257 [astro-ph].\n\n\n\nVaughan, S.; Edelson, R.; Warwick, R. and Uttley, P. (2003). On characterizing the variability properties of X-ray light curves from active galaxies, mnras 345, 1271–1284, arXiv:astro-ph/0307420 [astro-ph].\n\n\n\n","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Time-series","page":"API Reference","title":"Time series","text":"","category":"section"},{"location":"api/#Tonari.IrregularTimeStamps","page":"API Reference","title":"Tonari.IrregularTimeStamps","text":"IrregularTimeStamps\n\nA structure to store the time stamps of a time series. It contains the time stamps, the time step, the duration of the time series and a boolean to indicate if the time stamps are irregular. If the time stamps are irregular, the time step is the minimum time step between two time stamps.\n\nFields\n\ntime::AbstractVector{T}: the time stamps\nunit::Unitful.Unit: the unit of the time stamps (e.g. seconds, days, etc)\ntimezero::Td: the time of the first time stamp\nΔt::T: the time step\nduration::T: the duration of the time series\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.RegularTimeStamps","page":"API Reference","title":"Tonari.RegularTimeStamps","text":"RegularTimeStamps\n\nA structure to store the time stamps of a time series. It contains the time stamps, the time step, the duration of the time series and a boolean to indicate if the time stamps are irregular. If the time stamps are irregular, the time step is the minimum time step between two time stamps.\n\nFields\n\nΔt::T: the time step\nduration::T: the duration of the time series\nunit::Unitful.Unit: the unit of the time stamps (e.g. seconds, days, etc)\ntimezero::Td: the time of the first time stamp\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.TimeSeries","page":"API Reference","title":"Tonari.TimeSeries","text":"TimeSeries\n\nA structure to store a time series. It contains the time stamps, the data, and a dictionary to store metadata.\n\nFields\n\ntime::TimeStamps{Tt,Tz}: the time stamps\ndata::TimeSeriesData{Td, N}: the data\nmetadata::Dict{Symbol, Any}: a dictionary to store metadata\n\nEntries in metadata\n\n:name: a string to store the name of the time series\n:description: a string to store a description of the time series\n:unit: a string to store the unit(s) of the data\n:unit_time: unit of the time stamps (default: seconds)\n:timezero: a string to store the time of the first time stamp\n:fake: a boolean to indicate if the time series is fake\n:instrument: a string to store the instrument used to measure the time series\n:irregular: a boolean to indicate if the time series has irregular time stamps\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.TimeSeries-Union{Tuple{Td}, Tuple{T}, Tuple{AbstractVector{T}, Union{AbstractMatrix{Td}, Vector{Td}}}, Tuple{AbstractVector{T}, Union{AbstractMatrix{Td}, Vector{Td}}, Dict{Symbol, Any}}} where {T, Td}","page":"API Reference","title":"Tonari.TimeSeries","text":"TimeSeries(time::AbstractVector{T}, data::AbstractVector{Td}, metadata::Dict{Symbol,Any} = Dict{Symbol,Any}(), atol::T=0) where {T, Td}\n\nA constructor for the TimeSeries structure.\n\nThis function lets you create a TimeSeries structure using the times, data, and optional metadata.\n\nArguments\n\ntime::AbstractVector{T}: the time stamps of the time series (length N)\ndata::AbstractVector{Td}: the data array (N x M) where N is the number of time stamps and M is the number of columns, M can be 1 for a single column, then data is a vector\nmetadata::Dict{Symbol,Any}: a dictionary to store metadata\natol::T=0: the absolute tolerance for the time stamps to check if they are regular\n\nMetadata (optional but highly recommended)\n\n:irregular::Bool : a boolean to indicate if the time stamps are irregular\n:unit_time: the unit of the time stamps (default: seconds) using Unitful\n:timezero: the time of the first time stamp (default: time[1])\n:columns: the names of the columns (length M, default: y1, y2, ...), if M = 1, then the column is a Symbol\n:unit: the units of the columns (using Unitful) (length M, default: dimensionless), if M = 1, then the unit is a Symbol, but if all columns have the same unit, then the unit is a single unit\n:name: the name of the time series (optional)\n:description: a description of the time series (optional)\n:fake: a boolean to indicate if the time series is fake (optional)\n:instrument: the instrument used to measure the time series (optional)\n\nReturns\n\nTimeSeries: a TimeSeries structure with the time stamps, data, and metadata\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.TimeSeriesData","page":"API Reference","title":"Tonari.TimeSeriesData","text":"TimeSeriesData\n\nA type for the data in the time series.\n\nFields\n\nUnion{Vector{Symbol},Symbol}: the names of the columns, e.g. flux, error. Can be a vector of symbols or a single symbol if there is only one column.\ndata::Union{AbstractArray{T,2},Vector{T}}: the data array. Can be a matrix of data or a vector if there is only one column.\nunits::Union{Vector{Tu},Tu}: the units of the data. Can be a vector of units or a single unit if there is only one column or the same unit is used for all columns.\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.fill_gaps","page":"API Reference","title":"Tonari.fill_gaps","text":"fill_gaps(rng::AbstractRNG, t::Vector{Float64}, x::Vector{Float64}, σₓ = nothing; randomise_values::Bool = true, poisson::Bool = true)\n\nFill gaps in a time series data with linear interpolation. If randomise_values = true, the interpolated values are drawn from a normal distribution with the mean and standard deviation of the data. If poisson = true, the interpolated values are drawn from a Poisson distribution with the mean of the data.\n\nArguments\n\nrng::AbstractRNG: random number generator\nt::Vector{Float64}: time array\nx::Vector{Float64}: data array\nσₓ::Vector{Float64}: standard deviation of the data array (optional)\nrandomise_values::Bool: whether to randomise the interpolated values (default: true)\npoisson::Bool: whether to use a Poisson distribution for the interpolated values, this assumes that the data is in counts/dt units (default: true)\nΔt::Float64: the time step of the time series (optional)\n\nReturns\n\nt_filled::Vector{Float64}: the time array with the gaps filled\nx_filled::Vector{Float64}: the data array with the gaps filled\nσ_filled::Vector{Float64}: the standard deviation of the data array with the gaps filled (optional)\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.time_series_sanity_checks-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, Any}} where T","page":"API Reference","title":"Tonari.time_series_sanity_checks","text":"time_series_sanity_checks(t₁::AbstractVector{T}, x₁::AbstractVector{T}, σ₁=nothing) where T\n\nPerform sanity checks on the time series. The function checks the following:\n\nThe time and value vectors have the same length\nThe time and uncertainty vectors have the same length\nThe time series are sorted in ascending order\nThe time series do not contain infinities or NaNs\n\nArguments\n\nt₁::AbstractVector{T}: time points of the time series\nx₁::AbstractVector{T}: values of the time series\nσ₁::AbstractVector{T}=nothing: uncertainty of the time series\n\n\n\n\n\n","category":"method"},{"location":"api/#Models","page":"API Reference","title":"Models","text":"","category":"section"},{"location":"api/#Power-spectral-densities","page":"API Reference","title":"Power spectral densities","text":"","category":"section"},{"location":"api/#Tonari.DoubleBendingPowerLaw","page":"API Reference","title":"Tonari.DoubleBendingPowerLaw","text":" DoubleBendingPowerLaw(A, α₁, f₁, α₂, f₂, α₃)\n\nDouble bending power law model for the power spectral density\n\nA : the amplitude\nα₁: the first power law index\nf₁: the first bend frequency\nα₂: the second power law index\nf₂: the second bend frequency\nα₃: the third power law index\n\nmathcalP(f) =  Afrac(ff₁)^-α₁1 + (f  f₁)^α₂ - α₁frac11 + (f  f₂)^α₃ - α₂\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.Lorentzian","page":"API Reference","title":"Tonari.Lorentzian","text":"Lorentzian(A, γ, f₀)\n\nLorentzian model for the power spectral density\n\nA: the amplitude\nγ: the width of the peak\nf₀: the central frequency\n\nmathcalP(f) =  fracA4pi^2 (f - f₀)^2 + γ^2\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.PowerLaw","page":"API Reference","title":"Tonari.PowerLaw","text":" PowerLaw(α)\n\nPower law model for the power spectral density\n\nα: the power law index\n\nmathcalP(f) = A f^-α\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.QPO","page":"API Reference","title":"Tonari.QPO","text":"QPO(S₀, f₀,A Q)\n\nQPO model\n\nS₀: the amplitude at the peak\nf₀: the central frequency\nQ: quality factor\n\nmathcalP(f) =  fracS_0 f_0^4  left(f^ 2 -f_0^2right)^ 2 + f^2 f_0^2   Q^2 \n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.SingleBendingPowerLaw","page":"API Reference","title":"Tonari.SingleBendingPowerLaw","text":" SingleBendingPowerLaw(A, α₁, f₁, α₂)\n\nSingle bending power law model for the power spectral density\n\nA: the amplitude\nα₁: the first power law index\nf₁: the first bend frequency\nα₂: the second power law index\n\nmathcalP(f) =  A frac(ff₁)^-α₁1 + (f  f₁)^α₂ - α₁\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.separate_psd-Tuple{PowerSpectralDensity}","page":"API Reference","title":"Tonari.separate_psd","text":" separate_psd(psd::PowerSpectralDensity)\n\nSeparate the PSD into its BendingPowerLaw components and other components if it is a sum of PSDs\n\nArguments\n\npsd::PowerSpectralDensity: power spectral density or sum of PowerSpectralDensity objects\n\nReturn\n\npsd_continuum::Union{SumOfPowerSpectralDensity,PowerSpectralDensity,nothing}: continuum part of the psd\npsd_line::Union{PowerSpectralDensity,nothing,Vector{PowerSpectralDensity}}: non-continuum part of the psd\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulations","page":"API Reference","title":"Simulations","text":"","category":"section"},{"location":"api/#Tonari.Simulation","page":"API Reference","title":"Tonari.Simulation","text":"Simulation(model::Model, T::Real, Δt::Real, S_high::Real, S_low::Real, t::AbstractVector{Real})\n\nA struct that contains the information of a simulation of a stochastic process.\n\nFields\n\nmodel::Model: The power spectral density of the process.\nT::Real: The duration of the simulated time series. Note that the time stamps are from 0 to T, so the duration is T.\nΔt::Real: The sampling period, or minimum time difference between samples.\nS_high::Real: The factor by which the maximum frequency is multiplied for the simulation.\nS_low::Real: The factor by which the minimum frequency is divided for the simulation.\nt::AbstractVector{Real}: The time vector, in this case, the time at which the process is sampled. It is assumed that the time vector is sorted.\n\nConstructors\n\nSimulation(model::Model, T::Real, Δt::Real, S_high::Real, S_low::Real, t::AbstractVector{Real}): Constructs a simulation with regular sampling.\nSimulation(model::Model, T::Real, Δt::Real): Constructs a simulation with regular sampling, and sets S_high and S_low to 10.0.\nSimulation(model::Model, T::Real, Δt::Real, S_high::Real, S_low::Real): Constructs a simulation with the given parameters.\nSimulation(model::Model, t::AbstractVector{Real}, S_high::Real, S_low::Real): Constructs a simulation with sampling pattern given by t.\nSimulation(model::Model, t::AbstractVector{Real}): Constructs a simulation with sampling pattern given by t, and sets S_high and S_low to 10.0.\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsBase.sample","page":"API Reference","title":"StatsBase.sample","text":"sample(rng, sim, n=1, input_mean=0; σₓ = nothing, split_long=false, randomise_values=true, Fvar=nothing, alt=false, poisson=false, exponentiate=false, error_size=0.02)\n\nGenerate a time series with a given power spectral density (PSD) using the (Timmer and König, 1995) method.\n\nArguments\n\nrng::MersenneTwister: Random number generator.\nsim::Simulation: The simulation\nn::Int: Number of time series to generate. Default is 1.\ninput_mean::Real: The mean of the time series. Default is 0.\nσₓ::Array{Float64, 1}: The errorbars of the time series. Default is nothing.\nsplit_long::Bool: If true, the time series is split into shorter time series given by sim.S_low-1. Default is true.\nrandomise_values::Bool: If true, the values of the time series are randomised. Default is true.\nFvar::Real: The variance of the time series. Default is nothing.\nalt::Bool: If true, uses the alternative Timmer & Koenig method. Default is false.\npoisson::Bool: If true, Poisson noise is added to the time series. Default is false.\nexponentiate::Bool: If true, the time series is exponentiated. Default is false.\nerror_size::Real: The size of the error. Default is 0.05.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.draw_errorbars","page":"API Reference","title":"Tonari.draw_errorbars","text":"draw_errorbars(rng, x, Δt, poisson=false, error_size=0.05)\n\nDraw errorbars for the time series.\n\nArguments\n\nrng::MersenneTwister: Random number generator.\nx::Array{Float64, 1}: The values of the time series.\nΔt::Real: The sampling period.\npoisson::Bool: If true, Poisson noise is added to the time series. Default is false.\nerror_size::Real: The size of the error. Default is 0.05.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.findnearest-Tuple{Any, Any}","page":"API Reference","title":"Tonari.findnearest","text":"findnearest(a, b)\n\nFind the nearest value in b to each value in a. This assumes that a and b are sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.randomise_fluxes","page":"API Reference","title":"Tonari.randomise_fluxes","text":"randomise_fluxes(rng, xₛ, Δt, input_mean = 0.0; σ = nothing, Fvar = nothing, poisson = false, exponentiate = false, error_size = 0.05)\n\nRandomise the fluxes of the time series.\n\nArguments\n\nrng::MersenneTwister: Random number generator.\nxₛ::Array{Float64, 1}: The values of the time series.\nΔt::Real: The sampling period.\ninput_mean::Real: The mean of the time series. Default is 0.\nσ::Array{Float64, 1}: The errorbars of the time series. Default is nothing.\nFvar::Real: The variance of the time series. Default is nothing.\npoisson::Bool: If true, Poisson noise is added to the time series. Default is false.\nexponentiate::Bool: If true, the time series is exponentiated. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.sample_split_timeseries-NTuple{7, Any}","page":"API Reference","title":"Tonari.sample_split_timeseries","text":"sample_split_timeseries(x, t, t_desired, n_sim, n, n_slices, split_long)\n\nSplit the time series into shorter time series and sample at the desired time stamps.\n\nArguments\n\nx::Array{Float64, 1} or Vector{Matrix{Float64}}: The values of the time series. If there are multiple bands, the time series is a vector of matrices.\nt::Array{Float64, 1}: The time indexes of the time series.\nt_desired::Array{Float64, 1}: The desired time stamps.\nn_sim::Int: The number of simulations.\nn::Int: The number of time series to generate.\nn_slices::Int: The number of slices to break the time series into.\nsplit_long::Bool: If true, the time series is split into shorter time series. Default is true.\n\nReturns\n\nA tuple of two arrays: the first containing the time indexes of the shorter time series, and the second containing the values of the shorter time series.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.sample_timeseries-Tuple{Any, Any}","page":"API Reference","title":"Tonari.sample_timeseries","text":"sample_timeseries(t, y, M)\n\nExtract a random subset of points from the time series.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.split_longtimeseries-Tuple{Any, Any, Int64, Any}","page":"API Reference","title":"Tonari.split_longtimeseries","text":"split_longtimeseries(t, ts, n_slices, t_end)\n\nSplit a long time series into shorter time series. Break the time series into n_slices shorter time series. The short time series are of equal length.\n\nArguments\n\nt: The time indexes of the long time series.\nts: The values of the long time series.\nn_slices: The number of slices to break the time series into.\nt_end\n\nReturns\n\nA tuple of two lists: the first containing the time indexes of the shorter time series, and the second containing the values of the shorter time series.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.timmer_koenig-Tuple{Any, Random.AbstractRNG}","page":"API Reference","title":"Tonari.timmer_koenig","text":"timmer_koenig(psd, rng::random.AbstractRNG, alternative=false)\n\nGenerate a time series with a given power spectral density (PSD) using the (Timmer and König, 1995) method\n\nGiven N values of the power spectral density (PSD) 𝓟\nDraw 2N values from a standard normal distribution.\nThe amplitude of the randomised periodogram is given by A = N + i M\nThe randomised periodogram is given by 𝓟_rand = √(𝓟 / 2) * A\nThe first value of the randomised periodogram inserted and set to 0\nThe time series is obtained by taking the inverse Fourier transform of the randomised periodogram, with the function FFTW.irfft. We use the length of the time series as 2*(N+1)-1.\n\nThe alternative parametrisation is given by\n\nGiven N values of the power spectral density (PSD) 𝓟\nDraw N-1 values from a χ²(2)  distribution and 1 value from χ²₁(1), this is A the amplitude of the randomised periodogram\nDraw N values from a uniform distribution between 0 and 1, and set the last value to 0, this is θ the phase of the randomised periodogram\nThe randomised periodogram is given by 𝓟_rand = √(𝓟 / 2 * A) * exp(2πiθ)\nThe first value of the randomised periodogram inserted and set to 0\nThe time series is obtained by taking the inverse Fourier transform of the randomised periodogram, with the function FFTW.irfft. We use the length of the time series as 2*(N+1)-1.\n\nArguments\n\n𝓟::Array{Float64, 1}: PSD associated with the process\nrng::Random.AbstractRNG: Random number generator.\nα::Real: Multiplicative factor for the randomised periodogram. Default is 1.0. This can be a complex vector to add a phase to the time series.\n\nReturns\n\nx::Array{Float64, 1}: Time series with the given PSD.\n\n\n\n\n\n","category":"method"},{"location":"api/#Periodogram","page":"API Reference","title":"Periodogram","text":"","category":"section"},{"location":"api/#Tonari.coherence","page":"API Reference","title":"Tonari.coherence","text":"coherence(f, C̄, P̄₁, P̄₂, n_segments, y₁_err = nothing, y₂_err = nothing)\n\nCompute the coherence between two time series defined in (Vaughan and Nowak, 1997) using the cross-periodogram C̄, the mean power spectrum of the first time series P̄₁, and the mean power spectrum of the second time series P̄₂. The coherence is defined as:\n\ngamma^2 (f) = fracoverlineC(f)^2overlineP_1(f) overlineP_2(f)\n\nwith the error in the coherence given by:\n\nsigma_gamma^2 = sqrt2 sqrtgamma^2 frac1 - gamma^2sqrtM\n\nwhere M is the number of segments over which the coherence is computed.\n\nThe phase lag is defined as:\n\nDelta phi (f) = arg overlineC(f)\n\nwith the error in the phase lag given by:\n\nsigma_Delta phi = frac1 - gamma^2sqrt2 gamma^2 M\n\nThe time lag is defined as:\n\nDelta tau (f) = fracDelta phi2 pi f\n\nwith the error in the time lag given by:\n\nsigma_Delta tau = fracsigma_Delta phi2 pi f\n\nIf the errors in the time series are provided, the corrected coherence is computed using the method described in (Vaughan and Nowak, 1997).\n\nArguments\n\nf::Array{Float64, 1}: Frequency array.\nC̄::Array{Complex{Float64}, 1}: Cross-periodogram.\nP̄₁::Array{Float64, 1}: Mean power spectrum of the first time series.\nP̄₂::Array{Float64, 1}: Mean power spectrum of the second time series.\nn_segments::Int: Number of segments over which the coherence is computed.\ny₁_err::Array{Float64, 1}: Error in the first time series.\ny₂_err::Array{Float64, 1}: Error in the second time series.\n\nif the errors in the time series are not provided, the function returns the coherence, phase lag, and time lag. Otherwise, it returns the corrected coherence, phase lag, and time lag.\n\nReturns\n\nf::Array{Float64, 1}: Frequency array.\nγ²::Array{Float64, 1}: Coherence.\nΔφ::Array{Float64, 1}: Phase lag.\nγ²_err::Array{Float64, 1}: Error in the coherence.\nΔφ_err::Array{Float64, 1}: Error in the phase lag.\nΔτ::Array{Float64, 1}: Time lag.\nΔτ_err::Array{Float64, 1}: Error in the time lag.\nP̄₁::Array{Float64, 1}: Mean power spectrum of the first time series.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.cross_periodogram","page":"API Reference","title":"Tonari.cross_periodogram","text":"cross_periodogram(t, y₁, y₂, y₁_err = nothing, y₂_err = nothing; compute_coherence = true, apply_end_matching = false, subtract_mean = true)\n\nCompute the cross-periodogram between two time series y₁ and y₂ with time stamps t using the fast Fourier transform (FFT).\n\nArguments\n\nt::Array{Float64, 1}: Time stamps.\ny₁::Array{Float64, 1}: First time series data. Or a matrix of multiple time series.\ny₂::Array{Float64, 1}: Second time series data. Or a matrix of multiple time series.\ny₁_err::Array{Float64, 1}: Error in the first time series. Or a matrix of errors for multiple time series.\ny₂_err::Array{Float64, 1}: Error in the second time series Or a matrix of errors for multiple time series.\ncompute_coherence::Bool: Compute the coherence between the two time series. Default is true.\napply_end_matching::Bool: Apply end-matching to the data. Default is false.\nsubtract_mean::Bool: Subtract the mean from the data. Default is true.\n\nIf compute_coherence  is true, the function returns the coherence between the two time series. Otherwise, it returns the cross-periodogram and the mean power spectra of the two time series. see coherence function for the optional returns.\n\nReturns\n\nf::Array{Float64, 1}: Frequency array.\nC̄::Array{Complex{Float64}, 1}: Mean cross-periodogram.\nP̄₁::Array{Float64, 1}: Mean power spectrum of the first time series.\nP̄₂::Array{Float64, 1}: Mean power spectrum of the second time series.\nC::Array{Complex{Float64}, 1}: Cross-periodogram.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.end_matching-Tuple{Any, Any}","page":"API Reference","title":"Tonari.end_matching","text":"end_matching(y,t)\n\nEnd-match the data y with a straight line and subtract it from the data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.periodogram","page":"API Reference","title":"Tonari.periodogram","text":"periodogram(t,y, normalisation = \"default\"; apply_end_matching = false, subtract_mean = true)\n\nCompute the periodogram of the data y with time stamps t using the fast Fourier transform (FFT).\n\nThe periodogram is computed as the squared magnitude of the Fourier transform of the data. In practrice we use the real-valued fast Fourier transform (rfft) to compute the periodogram.\n\nArguments\n\nt::Array{Float64, 1}: Time stamps.\ny::Array{Float64, 1}: Time series data.\nnormalisation::Float64: Normalisation factor. Default is 2Δt / length(t).\napply_end_matching::Bool: Apply end-matching to the data. Default is false.\nsubtract_mean::Bool: Subtract the mean from the data. Default is true.\n\n\n\n\n\n","category":"function"},{"location":"api/#Correlations","page":"API Reference","title":"Correlations","text":"","category":"section"},{"location":"api/#Tonari.cross_correlate-Union{Tuple{T}, Tuple{Random.AbstractRNG, Vararg{AbstractVector{T}, 4}}} where T","page":"API Reference","title":"Tonari.cross_correlate","text":"cross_correlate(t₁::AbstractVector{T}, x₁::AbstractVector{T}, t₂::AbstractVector{T}, x₂::AbstractVector{T}; σ₁=nothing, σ₂=nothing, τ_list=nothing, Δτ=nothing, max_lag=nothing, local_estimate=false, both_ways=true, method=\"iccf\", compute_errors=false, peak_frac=0.8, bootstrap=false, n_simulations=1_000,\nskip_sanity_checks = false) where T\n\nCompute the cross-correlation function between two time series.\n\nThe function computes the cross-correlation function between two time series by linearly interpolating the second time series using the interpolated cross-correlation function (ICCF) method. Most of this code is based on the R package sour by Simon Vaughan, University of Leicester https://github.com/SimonVaughanDataAndCode/sour.\n\nArguments\n\nt₁::AbstractVector{T}: time stamps of the first time series\nx₁::AbstractVector{T}: values of the first time series\nt₂::AbstractVector{T}: time stamps of the second time series\nx₂::AbstractVector{T}: values of the second time series\n\nOptional arguments\n\nσ₁::AbstractVector{T} = nothing: uncertainty of the first time series\nσ₂::AbstractVector{T} = nothing: uncertainty of the second time series\nτ_list::AbstractVector{T} = nothing: list of time lags, if not provided, it will be computed based on the time range of the time series\nΔτ::T = nothing: time step between the time lags\nmax_lag::T = nothing: maximum time lag\nlocal_estimate::Bool = false: flag to estimate the local mean and standard deviation of the time series\nboth_ways::Bool = true: Compute the cross-correlation function in both ways, i.e., from the first to the second time series and from the second to the first time series\nmethod::String = \"iccf\": method to compute the cross-correlation function\ncompute_errors::Bool = false: flag to compute the errors of the cross-correlation function\npeak_frac::T = 0.8: fraction of the peak to integrate to get the lag\nbootstrap::Bool = false: flag to compute the errors using bootstrapping\nn_simulations::Int = 1_000: number of simulations to compute the errors\nskip_sanity_checks::Bool = false: flag to skip the sanity checks\n\nReturns\n\nτ_list::AbstractVector{T}: list of time lags\nr::AbstractVector{T}: cross-correlation function\nq::AbstractVector{T}: Distribution of centroid lags if compute_errors is true\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.get_lag_list-NTuple{5, Any}","page":"API Reference","title":"Tonari.get_lag_list","text":"get_lag_list(Δτ, max_lag,t₁,t₂,τ_list)\n\nGet the list of time lags to compute the cross-correlation function.\n\nArguments\n\nΔτ::T: time step between the time lags\nmax_lag::T: maximum time lag\nt₁::AbstractVector{T}: time stamps of the first time series\nt₂::AbstractVector{T}: time stamps of the second time series\nτ_list::AbstractVector{T}: list of time lags\n\nReturns\n\nτ_list::AbstractVector{T}: list of time lags\nΔτ::T: time step between the time lags\nmax_lag::T: maximum time lag\nn_lags::Int64: number of time lags\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.iccf-Union{Tuple{T}, NTuple{5, AbstractVector{T}}} where T","page":"API Reference","title":"Tonari.iccf","text":"iccf(t₁::AbstractVector{T}, x₁::AbstractVector{T}, t₂::AbstractVector{T}, x₂::AbstractVector{T}, τ_list::AbstractVector{T} ; local_estimate=false) where T\n\nCompute the interpolated cross-correlation function (ICCF) between two time series.\n\nThe function computes the cross-correlation function between two time series by linearly interpolating the second time series on the time points of the first time series. The ICCF is presented in Edelson et al. 2017  https://ui.adsabs.harvard.edu/abs/2017ApJ...840...41E/abstract and Peterson et al. 2004 https://ui.adsabs.harvard.edu/abs/2004ApJ...613..682P/abstract. The current implementation is based on the R package sour by Simon Vaughan, University of Leicester https://github.com/SimonVaughanDataAndCode/sour.\n\nhttps://ui.adsabs.harvard.edu/abs/1986ApJ...305..175G/abstract\n\nArguments\n\nt₁::AbstractVector{T}: time points of the first time series\nx₁::AbstractVector{T}: values of the first time series\nt₂::AbstractVector{T}: time points of the second time series\nx₂::AbstractVector{T}: values of the second time series\nτ_list::AbstractVector{T}: list of time lags\nlocal_estimate::Bool=false: flag to estimate the local mean and standard deviation of the time series\n\nReturns\n\nCCF::Vector{T}: cross-correlation function\nnx::Vector{Int64}: number of points in each time lag bin\n\nExample\n\nusing Random\nRandom.seed!(123)\nt₁ = 0:0.1:10\nx₁ = randn(length(t₁))\nt₂ = 0:0.1:10\nx₂ = randn(length(t₂))\nτ_list = -10:0.1:10\nCCF,nx = iccf(t₁, x₁, t₂, x₂, τ_list)\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.iccf_errors-Union{Tuple{T}, Tuple{Random.AbstractRNG, Vararg{AbstractVector{T}, 4}}} where T","page":"API Reference","title":"Tonari.iccf_errors","text":"iccf_errors(rng::AbstractRNG, t₁::AbstractVector{T}, x₁::AbstractVector{T}, t₂::AbstractVector{T}, x₂::AbstractVector{T}, σ₁::AbstractVector{T} = nothing, σ₂::AbstractVector{T} = nothing,peak_frac = 0.8,local_estimate = false,τ_list = nothing,bootstrap = false,n_simulations = 1_000) where {T}\n\nCompute the errors of the interpolated cross-correlation function (ICCF) between two time series.\n\nArguments\n\nrng::AbstractRNG: Random number generator\nt₁::AbstractVector{T}: time points of the first time series\nx₁::AbstractVector{T}: values of the first time series\nt₂::AbstractVector{T}: time points of the second time series\nx₂::AbstractVector{T}: values of the second time series\nσ₁::AbstractVector{T} = nothing: uncertainty of the first time series\nσ₂::AbstractVector{T} = nothing: uncertainty of the second time series\npeak_frac::T = 0.8: fraction of the peak to integrate to get the lag\nlocal_estimate::Bool = false: flag to estimate the local mean and standard deviation of the time series\nτ_list::AbstractVector{T} = nothing: list of time lags\nbootstrap::Bool = false: flag to compute the errors using bootstrapping\nn_simulations::Int = 1_000: number of simulations to compute the errors\n\nReturns\n\nq::Vector{T}: array of lags\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.randomise_lc_flux-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, AbstractVector{T}}} where T","page":"API Reference","title":"Tonari.randomise_lc_flux","text":"randomise_lc_flux(rng::AbstractRNG, t::Vector{Float64}, x::Vector{Float64}; σ::Vector{Float64} = nothing, bootstrap::Bool = false)\n\nRandomise the light curve by sampling with replacement. If bootstrap is true, the errors are not added to the light curve.\n\nArguments\n\nrng::AbstractRNG: Random number generator\nt::Vector{Float64}: Time array\nx::Vector{Float64}: Flux array\nσ::Vector{Float64}: Error array\nbootstrap::Bool: If true, the errors are not added to the light curve\n\nReturns\n\nt_samp::Vector{Float64}: Sampled time array\nx_samp::Vector{Float64}: Sampled flux array\nσ_samp::Vector{Float64}: Sampled error array\n\n\n\n\n\n","category":"method"},{"location":"periodogram/#Periodogram-computation","page":"Periodogram computation","title":"Periodogram computation","text":"","category":"section"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"The periodogram is an estimator for the power spectral density of a time series. It is defined as the squared magnitude of the discrete Fourier transform of the time series. We use FFTW.jl to compute the discrete Fourier transform efficiently:","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"X(f) = sum_n=1^N x_n e^-2pi i f n Delta t","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"where x_n is the time series , f is the frequency, and Delta t is the time interval between data points. The periodogram is then defined as","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"I(f) = frac2T X(f)^2","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"where T=NDelta t is the total duration of the time series. The periodogram is an unbiased estimator of the power spectral density.","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"using Tonari\nusing Random\nusing Plots\nusing StatsBase\nrng = MersenneTwister(1234)","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"Let's start by simulating time series data with a single bending power law power spectral density model.","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"psd_model = SingleBendingPowerLaw(1.0, 1.13, 1.2e-1, 4.22)\nf = 10.0 .^ range(-3, stop=2, length=1000)\npsd = psd_model(f)\nT, Δt = 504.2, 0.12\nsimu = Simulation(psd_model, T, Δt)\nt, x, σ = sample(rng, simu, 10, error_size = 0.25)","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"We compute the average periodogram of the time series data using the function periodogram. It is common to subtract the mean of the time series before computing the periodogram. The function also allows for applying end-matching, which is useful for reducing spectral leakage when the first and last points of the time series are not close to each other in value.","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"f,I = periodogram(t,x,apply_end_matching=false)","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"We can compare the periodogram to the model power spectral density. The noise level is given by 2Delta t times textmean(sigma^2), where sigma is the error on the time series data. See Appendix A of (Vaughan et al., 2003) for other normalisations and noise levels.","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"noise_level = 2Δt*mean(σ.^2)\n\nfx = 10.0 .^ range(-3, stop=0.5, length=1000)\nplot(f,I,yscale=:log10,xscale=:log10,xlabel=\"Frequency (Hz)\",ylabel=\"Power\",label=\"Periodogram\",framestyle=:box)\nplot!(fx,psd_model(fx),label=\"Model\",linewidth=2)\nhline!([noise_level],label=\"Noise level\",linewidth=2,linestyle=:dash)","category":"page"},{"location":"correlations/#Lag-and-correlations-between-two-time-series","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"","category":"section"},{"location":"correlations/","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"The lag and correlation functions are useful for understanding the relationship between two time series. Here we show how to compute the lag and correlation functions using the interpolated cross-correlation function (ICCF).","category":"page"},{"location":"correlations/#Interpolated-cross-correlation-function-(ICCF)","page":"Lag and correlations between two time series","title":"Interpolated cross-correlation function (ICCF)","text":"","category":"section"},{"location":"correlations/#Explanation","page":"Lag and correlations between two time series","title":"Explanation","text":"","category":"section"},{"location":"correlations/","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"As its name suggests, the interpolated cross-correlation function, is the cross-correlation function calculated on interpolated data. In astronomy, most long-term time series of quasars are often irregularly sampled due to observation constraints, seasons, weather, etc.","category":"page"},{"location":"correlations/","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"The seminal paper on the ICCF is Gaskell and Sparke (1986) where linear interpolation is used. Peterson et al. (1998) introduced flux-randomisation and ressampling to estimate uncertainties on the delay measurement.","category":"page"},{"location":"correlations/","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"This package is a Julia reimplementation of the R package sour written by Simon Vaughan https://github.com/SimonVaughanDataAndCode/sour/ and applied in Edelson et al. (2017).","category":"page"},{"location":"correlations/#Example","page":"Lag and correlations between two time series","title":"Example","text":"","category":"section"},{"location":"correlations/","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"Let's simulate a pair of time series with a known cross-spectral density and compute the ICCF. The ICCF is a method to estimate the cross-correlation function between two time series with different sampling rates. The ICCF is computed by interpolating the cross-correlation function between the two time series.","category":"page"},{"location":"correlations/","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"using Plots,Tonari,Random\n\nrng = MersenneTwister(4)\n\np1 = SingleBendingPowerLaw(1.0, 0.63, 10.0e-2, 3.22)\np2 = SingleBendingPowerLaw(1.0, 0.78, 13.0e-2, 4.81)\nΔϕ = ConstantTimeLag(18.5)\ncs = CrossSpectralDensity(p1, p2, Δϕ)\n\nT, Δt = 404.2, 0.1\nsimu = Simulation(cs, T, Δt)\nt, y, yerr = sample(rng, simu, 1, error_size = 0.05)\nN1, N2 = 511, 680\n# sample indices\np1 = sort(sample(rng, 1:length(t), N1, replace = false))\np2 = sort(sample(rng, 1:length(t), N2, replace = false))\n\nt₁, y₁, σ₁ = t[p1], y[1][p1, 1], yerr[1][p1, 1]\nt₂, y₂, σ₂ = t[p2], y[2][p2, 1], yerr[2][p2, 1]\n\nplot(t₁, y₁, yerr=σ₁, label=\"Time series 1\", xlabel=\"Time\", ylabel=\"Flux\", title=\"Time series 1 and 2\")\nplot!(t₂, y₂, yerr=σ₂, label=\"Time series 2\")","category":"page"},{"location":"correlations/","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"We can compute the ICCF using the cross_correlate function. The function returns the cross-correlation function, the time lags, and the centroid of the cross-correlation function from Monte Carlo simulations of the input time series.","category":"page"},{"location":"correlations/","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"τ_list, r, q = cross_correlate( t₁, y₁, t₂, y₂, σ₁ = σ₁, σ₂ = σ₂,max_lag=150,Δτ=1, compute_errors = true, n_simulations = 1000)\nplot(τ_list, r, label=\"ICCF\", xlabel=\"Time Lag\", ylabel=\"Correlation\", title=\"Interpolated cross-correlation function\")","category":"page"},{"location":"correlations/","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"We can compute the centroid of the ICCF and plot it as a vertical line.","category":"page"},{"location":"correlations/","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"m = r .>=0.8*maximum(r)\nτ_cent = sum(τ_list[m].*r[m])/sum(r[m])","category":"page"},{"location":"correlations/","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"We can plot the distribution of the centroid of the ICCF and use it for error estimation.","category":"page"},{"location":"correlations/","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"p = histogram(q, bins=50, label=\"Time Lag ICCF Centroid\", xlabel=\"Time Lag \", ylabel=\"Frequency\",)\np = vline!([τ_cent], label=\"Lag centroid\")","category":"page"},{"location":"correlations/#Discrete-Correlation-function-(DCF)","page":"Lag and correlations between two time series","title":"Discrete Correlation function (DCF)","text":"","category":"section"},{"location":"correlations/","page":"Lag and correlations between two time series","title":"Lag and correlations between two time series","text":"Not implemented yet. Edelson and Krolik (1988)","category":"page"},{"location":"#Tonari","page":"Home","title":"Tonari","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tonari is a Julia package for time series analysis with an emphasis on astronomical applications. It contains simple power spectral density models like SingleBendingPowerLaw for quasar variability studies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\",\"simulations.md\",\"simulations_delays.md\",\"periodogram.md\", \"correlations.md\",\"references.md\", \"api.md\"]\nDepth = 2","category":"page"},{"location":"simulations/#Simulating-univariate-time-series","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"","category":"section"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Let's simulate univariate time series data from a power spectrum model using the method of (Timmer and König, 1995). First we need to load the Tonari package and the Random package for generating random numbers.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"using Tonari\nusing Random\nusing Plots\nusing StatsBase","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Let's define the power spectrum model, for instance we will use SingleBendingPowerLaw.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"psd_model = SingleBendingPowerLaw(1.0, 1.13, 1.2e-1, 4.22)\nf = 10.0 .^ range(-3, stop=2, length=1000)\npsd = psd_model(f)\nplot(f, psd, xscale=:log10, yscale=:log10, xlabel=\"Frequency\", ylabel=\"Power Spectrum Density\", label=\"Power Spectrum\", framestyle=:box)","category":"page"},{"location":"simulations/#Regularly-sampled-data","page":"Simulating univariate time series","title":"Regularly sampled data","text":"","category":"section"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Now we can simulate the time series data. We first define a Simulation struct with the power spectrum model,the total time T, the time step Δt, the mean count rate μ, and the variance σ². We can also add the S_low and S_high parameters to the simulation object. The S_low and S_high parameters are factors that extend the grid of frequencies. This is useful to avoid the cyclic effect of the discrete Fourier transform, the resulting time series is extracted from a longer time interval.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"\nT, Δt = 504.2, 0.132\nsimu = Simulation(psd_model, T, Δt, 10, 10)","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Now we can simulate the time series data by sampling the generative model.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"rng = MersenneTwister(42)\nN = 10\nt, x, σ = sample(rng, simu, N, error_size = 0.25)","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"note: Note\nThe split_long parameter is used to split the long time series into smaller segments to speed up the computation, by default this is enabled. This is useful when we want to simulate a large number of time series.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Finally, we can plot the simulated time series data.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"scatter(t, x[:, 1], label = nothing, yerr = σ[:, 1], xlabel = \"Time (days)\", ylabel = \"Value\", framestyle = :box, ms = 2)","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"We can check that the simulated time series data has the same power spectrum as the model.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"f,I = periodogram(t,x,apply_end_matching=false,subtract_mean=true)\nnoise_level = 2Δt*mean(σ.^2)\nfx = 10.0 .^ range(-3, stop=0.5, length=1000)\nplot(f,I,yscale=:log10,xscale=:log10,xlabel=\"Frequency (Hz)\",ylabel=\"Power\",label=\"Periodogram\",framestyle=:box)\nplot!(fx,psd_model(fx),label=\"Model\",linewidth=2)\nhline!([noise_level],label=\"Noise level\",linewidth=2,linestyle=:dash)","category":"page"},{"location":"simulations/#Irregularly-sampled-data","page":"Simulating univariate time series","title":"Irregularly sampled data","text":"","category":"section"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"We can also simulate irregularly sampled data. We first need to define the time stamps t. Let's draw the times from a uniform distribution.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"t = sort(sample(rng,collect(0:Δt:T),150,replace=false))","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"We now define the Simulation object  with the new time stamps.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"simu = Simulation(psd_model, t, 10, 10)","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"We can now sample the generative model.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"t_obs, x, σ = sample(rng, simu, error_size = 0.25)\nscatter(t_obs, x, label = nothing, yerr = σ, xlabel = \"Time (days)\", ylabel = \"Value\", framestyle = :box, ms = 2)","category":"page"},{"location":"simulations/#With-custom-errorbars","page":"Simulating univariate time series","title":"With custom errorbars","text":"","category":"section"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"It is possible to give the errorbars to randomise the data. The errorbars are given as a vector of the same length as the time stamps.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"simu = Simulation(psd_model, t)\nσs = 0.1 .+ 0.1 * rand(rng, length(t_obs))\n\nt_obs, x, σ = sample(rng, simu, σₓ=σs)\n@assert σ==σs\nscatter(t_obs, x, label = nothing, yerr = σs, xlabel = \"Time (days)\", ylabel = \"Value\", framestyle = :box, ms = 2)","category":"page"}]
}
