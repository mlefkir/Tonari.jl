var documenterSearchIndex = {"docs":
[{"location":"simulations_delays/#Simulating-delayed-time-series","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"","category":"section"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"Let's simulate two time series with a delay ","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"using Tonari\nusing Random\nusing Plots\nusing StatsBase\nrng = MersenneTwister(42)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"Let's define the individual power spectral densities and the phase delay. We will use two bending power laws and a constant time delay.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"p1 = SingleBendingPowerLaw(1.0, 0.63, 10e-2, 3.22)\np2 = SingleBendingPowerLaw(1.0, 0.78, 13e-2, 3.81)\nŒîœï = ConstantTimeLag(12.35)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"The cross-spectral density is defined by the two power spectral densities and the phase delay.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"cs = CrossSpectralDensity(p1, p2, Œîœï)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"We can now simulate the time series using the Simulation type.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"T, Œît = 504.2, 0.133\nsimu = Simulation(cs, T, Œît)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"and sample 50 time series.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"t, y, yerr = sample(rng,simu,50,error_size=0.15)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"scatter(t,y[1][:,1],yerr=yerr[1][:,1],label=\"1\", framestyle=:box)\nscatter!(t,y[2][:,1],yerr=yerr[2][:,1],label=\"2\", framestyle=:box, xlabel=\"Time (days)\", ylabel=\"Value\")","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"The cross periodogram can be computed using the cross_periodogram function. Œ≥¬≤ is the coherence, ŒîœÜ the phase difference and ŒîœÑ the time delay.","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"f, Œ≥¬≤, Œ≥¬≤_corrected, ŒîœÜ, Œ≥¬≤_err, Œ≥¬≤_corrected_err, ŒîœÜ_err, ŒîœÑ, ŒîœÑ_err, PÃÑ‚ÇÅ, PÃÑ‚ÇÇ, N‚ÇÅ, N‚ÇÇ, n = cross_periodogram(t, y[1], y[2], yerr[1],yerr[2])","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"The individual periodograms can be plotted:","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"plot(f,PÃÑ‚ÇÅ,label=\"P‚ÇÅ\")\nplot!(f,PÃÑ‚ÇÇ,xscale=:log10,yscale=:log10,label=\"P‚ÇÇ\",xlabel=\"Frequency (d^-1)\",ylabel=\"Power\")\nhline!([N‚ÇÅ,N‚ÇÇ],linestyle=:dash,label=\"noise level\", framestyle=:box)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"The coherence and the phase difference can be plotted as a function of the frequency:","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"l = @layout [a; b]\np1 = scatter(f, Œ≥¬≤_corrected, yerr=Œ≥¬≤_corrected_err, label=\"Œ≥¬≤ corrected\",marker=:square,ms=4,xscale=:log10,size=(800,400))\np1 = scatter!(f, Œ≥¬≤, yerr=Œ≥¬≤_err, label=\"Œ≥¬≤\", xscale=:log10,ylims=(0,1.1),ms=4,ylabel=\"Coherence\",link=:x, framestyle=:box)\np2 = scatter(f, ŒîœÑ, yerr=ŒîœÑ_err, xscale=:log10, ylabel=\"Time delay (d)\",xlabel=\"Frequency (d^-1)\",link=:x, framestyle=:box,label=nothing)\np2 = hline!([Œîœï.ŒîœÑ ],color=:black,label=\"True delay\")\nplot(p1, p2, layout=l,size=(800,600))","category":"page"},{"location":"simulations_delays/#With-a-constant-phaselag","page":"Simulating delayed time series","title":"With a constant phaselag","text":"","category":"section"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"p1 = SingleBendingPowerLaw(1.0, 0.63, 10e-2, 3.22)\np2 = SingleBendingPowerLaw(1.0, 0.78, 13e-2, 3.81)\nŒîœï = ConstantPhaseLag(56.2,5*1/T)\n\ncs = CrossSpectralDensity(p1, p2, Œîœï)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"T, Œît = 504.2, 0.133\nsimu = Simulation(cs, T, Œît)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"t, y, yerr = sample(rng,simu,50,error_size=0.15)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"scatter(t,y[1][:,1],yerr=yerr[1][:,1],label=\"1\", framestyle=:box)\nscatter!(t,y[2][:,1],yerr=yerr[2][:,1],label=\"2\", framestyle=:box, xlabel=\"Time (days)\", ylabel=\"Value\")","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"f, Œ≥¬≤, Œ≥¬≤_corrected, ŒîœÜ, Œ≥¬≤_err, Œ≥¬≤_corrected_err, ŒîœÜ_err, ŒîœÑ, ŒîœÑ_err, PÃÑ‚ÇÅ, PÃÑ‚ÇÇ, N‚ÇÅ, N‚ÇÇ, n = cross_periodogram(t, y[1], y[2], yerr[1],yerr[2])","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"plot(f,PÃÑ‚ÇÅ,label=\"P‚ÇÅ\")\nplot!(f,PÃÑ‚ÇÇ,xscale=:log10,yscale=:log10,label=\"P‚ÇÇ\",xlabel=\"Frequency (d^-1)\",ylabel=\"Power\")\nhline!([N‚ÇÅ,N‚ÇÇ],linestyle=:dash,label=\"noise level\", framestyle=:box)","category":"page"},{"location":"simulations_delays/","page":"Simulating delayed time series","title":"Simulating delayed time series","text":"l = @layout [a; b ; c]\np1 = scatter(f, Œ≥¬≤_corrected, yerr=Œ≥¬≤_corrected_err, label=\"Œ≥¬≤ corrected\",marker=:square,ms=4,xscale=:log10,size=(800,400))\np1 = scatter!(f, Œ≥¬≤, yerr=Œ≥¬≤_err, label=\"Œ≥¬≤\", xscale=:log10,ylims=(0,1.1),ms=4,ylabel=\"Coherence\",link=:x, framestyle=:box)\n\np2 = scatter(f, ŒîœÜ, yerr=ŒîœÜ_err, xscale=:log10, ylabel=\"Time delay (d)\",xlabel=\"Frequency (d^-1)\",link=:x, framestyle=:box,label=nothing)\np2 = plot!(f,calculate(Œîœï,f) .* 2 .*pi .* f )\nprintln(calculate(Œîœï,f[1]) .* 2 .*pi .* f[1] )\n\np3 = scatter(f, ŒîœÑ, yerr=ŒîœÑ_err, xscale=:log10, ylabel=\"Time delay (d)\",xlabel=\"Frequency (d^-1)\",link=:x, framestyle=:box,label=nothing)\np3 = plot!(f,-calculate(Œîœï,f) )\n\nplot(p1, p2,p3, layout=l,size=(800,900))","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Timmer,¬†J. and K√∂nig,¬†M. (1995). On generating power law noise. aap 300, 707.\n\n\n\nVaughan,¬†B.¬†A. and Nowak,¬†M.¬†A. (1997). X-Ray Variability Coherence: How to Compute It, What It Means, and How It Constrains Models of GX 339-4 and Cygnus X-1, apjl 474, L43-L46, arXiv:astro-ph/9610257 [astro-ph].\n\n\n\nVaughan,¬†S.; Edelson,¬†R.; Warwick,¬†R. and Uttley,¬†P. (2003). On characterizing the variability properties of X-ray light curves from active galaxies, mnras 345, 1271‚Äì1284, arXiv:astro-ph/0307420 [astro-ph].\n\n\n\n","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Models","page":"API Reference","title":"Models","text":"","category":"section"},{"location":"api/#Power-spectral-densities","page":"API Reference","title":"Power spectral densities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Tonari]\nPages = [\"psd.jl\"]\nPrivate = false\nOrder   = [:type, :function]","category":"page"},{"location":"api/#Tonari.DoubleBendingPowerLaw","page":"API Reference","title":"Tonari.DoubleBendingPowerLaw","text":" DoubleBendingPowerLaw(Œ±‚ÇÅ, f‚ÇÅ, Œ±‚ÇÇ, f‚ÇÇ, Œ±‚ÇÉ)\n\nDouble bending power law model for the power spectral density\n\nŒ±‚ÇÅ: the first power law index\nf‚ÇÅ: the first bend frequency\nŒ±‚ÇÇ: the second power law index\nf‚ÇÇ: the second bend frequency\nŒ±‚ÇÉ: the third power law index\n\nmathcalP(f) =  Afrac(ff‚ÇÅ)^-Œ±‚ÇÅ1 + (f  f‚ÇÅ)^Œ±‚ÇÇ - Œ±‚ÇÅfrac11 + (f  f‚ÇÇ)^Œ±‚ÇÉ - Œ±‚ÇÇ\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.Lorentzian","page":"API Reference","title":"Tonari.Lorentzian","text":"Lorentzian(A, Œ≥, f‚ÇÄ)\n\nLorentzian model for the power spectral density\n\nA: the amplitude\nŒ≥: the width of the peak\nf‚ÇÄ: the central frequency\n\nmathcalP(f) =  fracA4pi^2 (f - f‚ÇÄ)^2 + Œ≥^2\n\n\n\n\n\n","category":"type"},{"location":"api/#Tonari.SingleBendingPowerLaw","page":"API Reference","title":"Tonari.SingleBendingPowerLaw","text":" SingleBendingPowerLaw(A, Œ±‚ÇÅ, f‚ÇÅ, Œ±‚ÇÇ)\n\nSingle bending power law model for the power spectral density\n\nA: the amplitude\nŒ±‚ÇÅ: the first power law index\nf‚ÇÅ: the first bend frequency\nŒ±‚ÇÇ: the second power law index\n\nmathcalP(f) =  A frac(ff‚ÇÅ)^-Œ±‚ÇÅ1 + (f  f‚ÇÅ)^Œ±‚ÇÇ - Œ±‚ÇÅ\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulations","page":"API Reference","title":"Simulations","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Tonari]\nPages = [\"simulate.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"api/#Tonari.Simulation","page":"API Reference","title":"Tonari.Simulation","text":"Simulation(model::Model, T::Real, Œît::Real, S_high::Real, S_low::Real, t::AbstractVector{Real})\n\nA struct that contains the information of a simulation of a stochastic process.\n\nFields\n\nmodel::Model: The power spectral density of the process.\nT::Real: The duration of the simulated time series. Note that the time stamps are from 0 to T, so the duration is T.\nŒît::Real: The sampling period, or minimum time difference between samples.\nS_high::Real: The factor by which the maximum frequency is multiplied for the simulation.\nS_low::Real: The factor by which the minimum frequency is divided for the simulation.\nt::AbstractVector{Real}: The time vector, in this case, the time at which the process is sampled. It is assumed that the time vector is sorted.\n\nConstructors\n\nSimulation(model::Model, T::Real, Œît::Real, S_high::Real, S_low::Real, t::AbstractVector{Real}): Constructs a simulation with regular sampling.\nSimulation(model::Model, T::Real, Œît::Real): Constructs a simulation with regular sampling, and sets S_high and S_low to 10.0.\nSimulation(model::Model, T::Real, Œît::Real, S_high::Real, S_low::Real): Constructs a simulation with the given parameters.\nSimulation(model::Model, t::AbstractVector{Real}, S_high::Real, S_low::Real): Constructs a simulation with sampling pattern given by t.\nSimulation(model::Model, t::AbstractVector{Real}): Constructs a simulation with sampling pattern given by t, and sets S_high and S_low to 10.0.\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsBase.sample","page":"API Reference","title":"StatsBase.sample","text":"sample(rng, sim, n=1, input_mean=0; œÉ‚Çì = nothing, split_long=false, randomise_values=true, Fvar=nothing, alt=false, poisson=false, exponentiate=false, error_size=0.02)\n\nGenerate a time series with a given power spectral density (PSD) using the (Timmer and K√∂nig, 1995) method.\n\nArguments\n\nrng::MersenneTwister: Random number generator.\nsim::Simulation: The simulation \nn::Int: Number of time series to generate. Default is 1.\ninput_mean::Real: The mean of the time series. Default is 0.\nœÉ‚Çì::Array{Float64, 1}: The errorbars of the time series. Default is nothing.\nsplit_long::Bool: If true, the time series is split into shorter time series given by sim.S_low-1. Default is true.\nrandomise_values::Bool: If true, the values of the time series are randomised. Default is true.\nFvar::Real: The variance of the time series. Default is nothing.\nalt::Bool: If true, uses the alternative Timmer & Koenig method. Default is false. \npoisson::Bool: If true, Poisson noise is added to the time series. Default is false.\nexponentiate::Bool: If true, the time series is exponentiated. Default is false.\nerror_size::Real: The size of the error. Default is 0.05.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.draw_errorbars","page":"API Reference","title":"Tonari.draw_errorbars","text":"draw_errorbars(rng, x, Œît, poisson=false, error_size=0.05)\n\nDraw errorbars for the time series.\n\nArguments\n\nrng::MersenneTwister: Random number generator.\nx::Array{Float64, 1}: The values of the time series.\nŒît::Real: The sampling period.\npoisson::Bool: If true, Poisson noise is added to the time series. Default is false.\nerror_size::Real: The size of the error. Default is 0.05.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.findnearest-Tuple{Any, Any}","page":"API Reference","title":"Tonari.findnearest","text":"findnearest(a, b)\n\nFind the nearest value in b to each value in a. This assumes that a and b are sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.randomise_fluxes","page":"API Reference","title":"Tonari.randomise_fluxes","text":"randomise_fluxes(rng, x‚Çõ, Œît, input_mean = 0.0; œÉ = nothing, Fvar = nothing, poisson = false, exponentiate = false, error_size = 0.05)\n\nRandomise the fluxes of the time series.\n\nArguments\n\nrng::MersenneTwister: Random number generator.\nx‚Çõ::Array{Float64, 1}: The values of the time series.\nŒît::Real: The sampling period.\ninput_mean::Real: The mean of the time series. Default is 0.\nœÉ::Array{Float64, 1}: The errorbars of the time series. Default is nothing.\nFvar::Real: The variance of the time series. Default is nothing.\npoisson::Bool: If true, Poisson noise is added to the time series. Default is false.\nexponentiate::Bool: If true, the time series is exponentiated. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.sample_split_timeseries-NTuple{7, Any}","page":"API Reference","title":"Tonari.sample_split_timeseries","text":"sample_split_timeseries(x, t, t_desired, n_sim, n, n_slices, split_long)\n\nSplit the time series into shorter time series and sample at the desired time stamps.\n\nArguments\n\nx::Array{Float64, 1} or Vector{Matrix{Float64}}: The values of the time series. If there are multiple bands, the time series is a vector of matrices.\nt::Array{Float64, 1}: The time indexes of the time series.\nt_desired::Array{Float64, 1}: The desired time stamps.\nn_sim::Int: The number of simulations.\nn::Int: The number of time series to generate.\nn_slices::Int: The number of slices to break the time series into.\nsplit_long::Bool: If true, the time series is split into shorter time series. Default is true.\n\nReturns\n\nA tuple of two arrays: the first containing the time indexes of the shorter time series, and the second containing the values of the shorter time series.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.sample_timeseries-Tuple{Any, Any}","page":"API Reference","title":"Tonari.sample_timeseries","text":"sample_timeseries(t, y, M)\n\nExtract a random subset of points from the time series.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.split_longtimeseries-Tuple{Any, Any, Int64, Any}","page":"API Reference","title":"Tonari.split_longtimeseries","text":"split_longtimeseries(t, ts, n_slices, t_end)\n\nSplit a long time series into shorter time series. Break the time series into n_slices shorter time series. The short time series are of equal length.\n\nArguments\n\nt: The time indexes of the long time series.\nts: The values of the long time series.\nn_slices: The number of slices to break the time series into.\nt_end\n\nReturns\n\nA tuple of two lists: the first containing the time indexes of the shorter time series, and the second containing the values of the shorter time series.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.timmer_koenig-Tuple{Any, Random.AbstractRNG}","page":"API Reference","title":"Tonari.timmer_koenig","text":"timmer_koenig(psd, rng::random.AbstractRNG, alternative=false)\n\nGenerate a time series with a given power spectral density (PSD) using the (Timmer and K√∂nig, 1995) method\n\nGiven N values of the power spectral density (PSD) ùìü\nDraw 2N values from a standard normal distribution. \nThe amplitude of the randomised periodogram is given by A = N + i M\nThe randomised periodogram is given by ùìü_rand = ‚àö(ùìü / 2) * A\nThe first value of the randomised periodogram inserted and set to 0\nThe time series is obtained by taking the inverse Fourier transform of the randomised periodogram, with the function FFTW.irfft. We use the length of the time series as 2*(N+1)-1.\n\nThe alternative parametrisation is given by\n\nGiven N values of the power spectral density (PSD) ùìü\nDraw N-1 values from a œá¬≤(2)  distribution and 1 value from œá¬≤‚ÇÅ(1), this is A the amplitude of the randomised periodogram\nDraw N values from a uniform distribution between 0 and 1, and set the last value to 0, this is Œ∏ the phase of the randomised periodogram\nThe randomised periodogram is given by ùìü_rand = ‚àö(ùìü / 2 * A) * exp(2œÄiŒ∏)\nThe first value of the randomised periodogram inserted and set to 0\nThe time series is obtained by taking the inverse Fourier transform of the randomised periodogram, with the function FFTW.irfft. We use the length of the time series as 2*(N+1)-1.\n\nArguments\n\nùìü::Array{Float64, 1}: PSD associated with the process\nrng::Random.AbstractRNG: Random number generator.\nŒ±::Real: Multiplicative factor for the randomised periodogram. Default is 1.0. This can be a complex vector to add a phase to the time series.\n\nReturns\n\nx::Array{Float64, 1}: Time series with the given PSD.\n\n\n\n\n\n","category":"method"},{"location":"api/#Periodogram","page":"API Reference","title":"Periodogram","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Tonari]\nPages = [\"periodogram.jl\"]\nOrder = [:function]","category":"page"},{"location":"api/#Tonari.coherence","page":"API Reference","title":"Tonari.coherence","text":"coherence(f, CÃÑ, PÃÑ‚ÇÅ, PÃÑ‚ÇÇ, n_segments, y‚ÇÅ_err = nothing, y‚ÇÇ_err = nothing)\n\nCompute the coherence between two time series defined in (Vaughan and Nowak, 1997) using the cross-periodogram CÃÑ, the mean power spectrum of the first time series PÃÑ‚ÇÅ, and the mean power spectrum of the second time series PÃÑ‚ÇÇ. The coherence is defined as:\n\ngamma^2 (f) = fracoverlineC(f)^2overlineP_1(f) overlineP_2(f)\n\nwith the error in the coherence given by:\n\nsigma_gamma^2 = sqrt2 sqrtgamma^2 frac1 - gamma^2sqrtM\n\nwhere M is the number of segments over which the coherence is computed.\n\nThe phase lag is defined as:\n\nDelta phi (f) = arg overlineC(f)\n\nwith the error in the phase lag given by:\n\nsigma_Delta phi = frac1 - gamma^2sqrt2 gamma^2 M\n\nThe time lag is defined as:\n\nDelta tau (f) = fracDelta phi2 pi f\n\nwith the error in the time lag given by:\n\nsigma_Delta tau = fracsigma_Delta phi2 pi f\n\nIf the errors in the time series are provided, the corrected coherence is computed using the method described in (Vaughan and Nowak, 1997).\n\nArguments\n\nf::Array{Float64, 1}: Frequency array.\nCÃÑ::Array{Complex{Float64}, 1}: Cross-periodogram.\nPÃÑ‚ÇÅ::Array{Float64, 1}: Mean power spectrum of the first time series.\nPÃÑ‚ÇÇ::Array{Float64, 1}: Mean power spectrum of the second time series.\nn_segments::Int: Number of segments over which the coherence is computed.\ny‚ÇÅ_err::Array{Float64, 1}: Error in the first time series.\ny‚ÇÇ_err::Array{Float64, 1}: Error in the second time series.\n\nif the errors in the time series are not provided, the function returns the coherence, phase lag, and time lag. Otherwise, it returns the corrected coherence, phase lag, and time lag.\n\nReturns\n\nf::Array{Float64, 1}: Frequency array.\nŒ≥¬≤::Array{Float64, 1}: Coherence.\nŒîœÜ::Array{Float64, 1}: Phase lag.\nŒ≥¬≤_err::Array{Float64, 1}: Error in the coherence.\nŒîœÜ_err::Array{Float64, 1}: Error in the phase lag.\nŒîœÑ::Array{Float64, 1}: Time lag.\nŒîœÑ_err::Array{Float64, 1}: Error in the time lag.\nPÃÑ‚ÇÅ::Array{Float64, 1}: Mean power spectrum of the first time series.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.cross_periodogram","page":"API Reference","title":"Tonari.cross_periodogram","text":"cross_periodogram(t, y‚ÇÅ, y‚ÇÇ, y‚ÇÅ_err = nothing, y‚ÇÇ_err = nothing; compute_coherence = true, apply_end_matching = false, subtract_mean = true)\n\nCompute the cross-periodogram between two time series y‚ÇÅ and y‚ÇÇ with time stamps t using the fast Fourier transform (FFT).\n\nArguments\n\nt::Array{Float64, 1}: Time stamps.\ny‚ÇÅ::Array{Float64, 1}: First time series data. Or a matrix of multiple time series. \ny‚ÇÇ::Array{Float64, 1}: Second time series data. Or a matrix of multiple time series.\ny‚ÇÅ_err::Array{Float64, 1}: Error in the first time series. Or a matrix of errors for multiple time series.\ny‚ÇÇ_err::Array{Float64, 1}: Error in the second time series Or a matrix of errors for multiple time series.\ncompute_coherence::Bool: Compute the coherence between the two time series. Default is true.\napply_end_matching::Bool: Apply end-matching to the data. Default is false.\nsubtract_mean::Bool: Subtract the mean from the data. Default is true.\n\nIf compute_coherence  is true, the function returns the coherence between the two time series. Otherwise, it returns the cross-periodogram and the mean power spectra of the two time series. see coherence function for the optional returns.\n\nReturns\n\nf::Array{Float64, 1}: Frequency array.\nCÃÑ::Array{Complex{Float64}, 1}: Mean cross-periodogram.\nPÃÑ‚ÇÅ::Array{Float64, 1}: Mean power spectrum of the first time series.\nPÃÑ‚ÇÇ::Array{Float64, 1}: Mean power spectrum of the second time series.\nC::Array{Complex{Float64}, 1}: Cross-periodogram.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tonari.end_matching-Tuple{Any, Any}","page":"API Reference","title":"Tonari.end_matching","text":"end_matching(y,t)\n\nEnd-match the data y with a straight line and subtract it from the data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tonari.periodogram","page":"API Reference","title":"Tonari.periodogram","text":"periodogram(y, t, normalisation = \"default\"; apply_end_matching = false, subtract_mean = true)\n\nCompute the periodogram of the data y with time stamps t using the fast Fourier transform (FFT).\n\nThe periodogram is computed as the squared magnitude of the Fourier transform of the data. In practrice we  use the real-valued fast Fourier transform (rfft) to compute the periodogram.\n\nArguments\n\ny::Array{Float64, 1}: Time series data.\nt::Array{Float64, 1}: Time stamps.\nnormalisation::Float64: Normalisation factor. Default is 2Œît / length(t).\napply_end_matching::Bool: Apply end-matching to the data. Default is false.\nsubtract_mean::Bool: Subtract the mean from the data. Default is true.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Tonari]\nPages = [\"timeseries.jl\"]\nOrder = [:function]","category":"page"},{"location":"api/#Tonari.fill_gaps","page":"API Reference","title":"Tonari.fill_gaps","text":"fill_gaps(rng::AbstractRNG, t::Vector{Float64}, x::Vector{Float64}, œÉ‚Çì = nothing; randomise_values::Bool = true, poisson::Bool = true)\n\nFill gaps in a time series data with linear interpolation. If randomise_values = true, the interpolated values are drawn from a normal distribution with the mean and standard deviation of the data. If poisson = true, the interpolated values are drawn from a Poisson distribution with the mean of the data.\n\nArguments\n\nrng::AbstractRNG: random number generator\nt::Vector{Float64}: time array\nx::Vector{Float64}: data array\nœÉ‚Çì::Vector{Float64}: standard deviation of the data array (optional)\nrandomise_values::Bool: whether to randomise the interpolated values\npoisson::Bool: whether to use a Poisson distribution for the interpolated values, this assumes that the data is in counts/dt\n\n\n\n\n\n","category":"function"},{"location":"periodogram/#Periodogram-computation","page":"Periodogram computation","title":"Periodogram computation","text":"","category":"section"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"The periodogram is an estimator for the power spectral density of a time series. It is defined as the squared magnitude of the discrete Fourier transform of the time series. We use the FFTW.jl package to compute the discrete Fourier transform efficiently:","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"X(f) = sum_n=1^N x_n e^-2pi i f n Delta t","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"where x_n is the time series , f is the frequency, and Delta t is the time interval between data points. The periodogram is then defined as ","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"I(f) = frac2T X(f)^2","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"where T=NDelta t is the total duration of the time series. The periodogram is an unbiased estimator of the power spectral density.","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"using Tonari\nusing Random\nusing Plots\nusing StatsBase \nrng = MersenneTwister(1234)","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"Let's start by simulating time series data with a single bending power law power spectral density model.","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"psd_model = SingleBendingPowerLaw(1.0, 1.13, 1.2e-1, 4.22)\nf = 10.0 .^ range(-3, stop=2, length=1000)\npsd = psd_model(f)\nT, Œît = 504.2, 0.12\nsimu = Simulation(psd_model, T, Œît)\nt, x, œÉ = sample(rng, simu, 10, error_size = 0.25)","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"We compute the average periodogram of the time series data using the function periodogram. It is common to subtract the mean of the time series before computing the periodogram. The function also allows for applying end-matching, which is useful for reducing spectral leakage when the first and last points of the time series are not close to each other in value. ","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"f,I = periodogram(t,x,apply_end_matching=false)","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"We can compare the periodogram to the model power spectral density. The noise level is given by 2Delta t times textmean(sigma^2), where sigma is the error on the time series data. See Appendix A of (Vaughan et al., 2003) for other normalisations and noise levels.","category":"page"},{"location":"periodogram/","page":"Periodogram computation","title":"Periodogram computation","text":"noise_level = 2Œît*mean(œÉ.^2)\n\nfx = 10.0 .^ range(-3, stop=0.5, length=1000)\nplot(f,I,yscale=:log10,xscale=:log10,xlabel=\"Frequency (Hz)\",ylabel=\"Power\",label=\"Periodogram\",framestyle=:box)\nplot!(fx,psd_model(fx),label=\"Model\",linewidth=2)\nhline!([noise_level],label=\"Noise level\",linewidth=2,linestyle=:dash)","category":"page"},{"location":"#Tonari","page":"Home","title":"Tonari","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tonari is a Julia package for time series analysis with an emphasis on astronomical applications.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\",\"simulations.md\",\"simulations_delays.md\",\"periodogram.md\", \"references.md\", \"api.md\"]\nDepth = 2","category":"page"},{"location":"simulations/#Simulating-univariate-time-series","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"","category":"section"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Let's simulate univariate time series data from a power spectrum model using the method of (Timmer and K√∂nig, 1995).  First we need to load the Tonari package and the Random package for generating random numbers.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"using Tonari\nusing Random\nusing Plots\nusing StatsBase","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Let's define the power spectrum model, for instance we will use SingleBendingPowerLaw. ","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"psd_model = SingleBendingPowerLaw(1.0, 1.13, 1.2e-1, 4.22)\nf = 10.0 .^ range(-3, stop=2, length=1000)\npsd = psd_model(f)\nplot(f, psd, xscale=:log10, yscale=:log10, xlabel=\"Frequency\", ylabel=\"Power Spectrum Density\", label=\"Power Spectrum\", framestyle=:box)","category":"page"},{"location":"simulations/#Regularly-sampled-data","page":"Simulating univariate time series","title":"Regularly sampled data","text":"","category":"section"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Now we can simulate the time series data. We first define a Simulation struct with the power spectrum model,the total time T, the time step Œît, the mean count rate Œº, and the variance œÉ¬≤. We can also add the S_low and S_high parameters to the simulation object. The S_low and S_high parameters are factors that extend the grid of frequencies. This is useful to avoid the cyclic effect of the discrete Fourier transform, the resulting time series is extracted from a longer time interval.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"\nT, Œît = 504.2, 0.132\nsimu = Simulation(psd_model, T, Œît, 10, 10)","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Now we can simulate the time series data by sampling the generative model.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"rng = MersenneTwister(42)\nN = 10\nt, x, œÉ = sample(rng, simu, N, error_size = 0.25)","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"note: Note\nThe split_long parameter is used to split the long time series into smaller segments to speed up the computation, by default this is enabled. This is useful when we want to simulate a large number of time series.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"Finally, we can plot the simulated time series data.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"scatter(t, x[:, 1], label = nothing, yerr = œÉ[:, 1], xlabel = \"Time (days)\", ylabel = \"Value\", framestyle = :box, ms = 2)","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"We can check that the simulated time series data has the same power spectrum as the model.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"f,I = periodogram(t,x,apply_end_matching=false,subtract_mean=true)\nnoise_level = 2Œît*mean(œÉ.^2)\nfx = 10.0 .^ range(-3, stop=0.5, length=1000)\nplot(f,I,yscale=:log10,xscale=:log10,xlabel=\"Frequency (Hz)\",ylabel=\"Power\",label=\"Periodogram\",framestyle=:box)\nplot!(fx,psd_model(fx),label=\"Model\",linewidth=2)\nhline!([noise_level],label=\"Noise level\",linewidth=2,linestyle=:dash)","category":"page"},{"location":"simulations/#Irregularly-sampled-data","page":"Simulating univariate time series","title":"Irregularly sampled data","text":"","category":"section"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"We can also simulate irregularly sampled data. We first need to define the time stamps t. Let's draw the times from a uniform distribution.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"t = sort(sample(rng,collect(0:Œît:T),150,replace=false))","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"We now define the Simulation object  with the new time stamps.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"simu = Simulation(psd_model, t, 10, 10)","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"We can now sample the generative model.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"t_obs, x, œÉ = sample(rng, simu, error_size = 0.25)\nscatter(t_obs, x, label = nothing, yerr = œÉ, xlabel = \"Time (days)\", ylabel = \"Value\", framestyle = :box, ms = 2)","category":"page"},{"location":"simulations/#With-custom-errorbars","page":"Simulating univariate time series","title":"With custom errorbars","text":"","category":"section"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"It is possible to give the errorbars to randomise the data. The errorbars are given as a vector of the same length as the time stamps.","category":"page"},{"location":"simulations/","page":"Simulating univariate time series","title":"Simulating univariate time series","text":"simu = Simulation(psd_model, t)\nœÉs = 0.1 .+ 0.1 * rand(rng, length(t_obs))\n\nt_obs, x, œÉ = sample(rng, simu, œÉ‚Çì=œÉs)\n@assert œÉ==œÉs\nscatter(t_obs, x, label = nothing, yerr = œÉs, xlabel = \"Time (days)\", ylabel = \"Value\", framestyle = :box, ms = 2)","category":"page"}]
}
